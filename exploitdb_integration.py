#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import json
import logging
import subprocess
import shutil
import requests
import time
import tempfile
import platform
import zipfile
import re
from typing import Dict, List, Any, Optional, Union

# Add the parent directory to the path to import security_tools_integration
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Import from the security tools integration
from security_tools_integration import SecurityToolBase, register_tool, get_tools_directory, download_file

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("exploitdb_integration.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ExploitDBIntegration")


@register_tool
class ExploitDB(SecurityToolBase):
    """
    Exploit-DB - A database of public exploits and corresponding vulnerable software
    
    Features:
    - Comprehensive exploit database
    - Searchable by CVE ID or vulnerability type
    - Regularly updated with new exploits
    - Includes proof-of-concept code
    - Provides detailed vulnerability information
    """
    
    def __init__(self):
        self.exploitdb_path = os.path.join(get_tools_directory(), "exploitdb")
        self.searchsploit_path = os.path.join(self.exploitdb_path, "searchsploit")
        self.exploits_csv = os.path.join(self.exploitdb_path, "files_exploits.csv")
        self.api_url = "https://www.exploit-db.com/api"
        
    @classmethod
    def get_capabilities(cls):
        """Return the capabilities of this security tool"""
        return {
            "name": "Exploit-DB",
            "description": "A database of public exploits and corresponding vulnerable software",
            "actions": ["search", "get_exploit", "search_cve", "search_type", "search_platform"],
            "target_types": ["cve", "software", "vendor", "author", "platform"],
            "output_formats": ["json", "text", "csv"],
            "dependencies": ["git"]
        }
        
    def check_installation(self):
        """Check if Exploit-DB is installed"""
        if os.path.exists(self.searchsploit_path):
            return True
            
        # Check if searchsploit is in PATH
        searchsploit_in_path = shutil.which("searchsploit")
        if searchsploit_in_path:
            self.searchsploit_path = searchsploit_in_path
            self.exploitdb_path = os.path.dirname(os.path.dirname(searchsploit_in_path))
            self.exploits_csv = os.path.join(self.exploitdb_path, "files_exploits.csv")
            return True
            
        return False
        
    def install(self):
        """Install Exploit-DB"""
        os.makedirs(self.exploitdb_path, exist_ok=True)
        
        # Clone Exploit-DB repository
        logger.info("Cloning Exploit-DB repository...")
        result = self.run_command(["git", "clone", "https://github.com/offensive-security/exploitdb.git", self.exploitdb_path])
        
        if result["returncode"] != 0:
            # Try downloading as zip if git fails
            logger.info("Git clone failed, trying direct download...")
            download_url = "https://github.com/offensive-security/exploitdb/archive/master.zip"
            zip_path = os.path.join(self.exploitdb_path, "exploitdb.zip")
            
            if not download_file(download_url, zip_path):
                raise Exception("Failed to download Exploit-DB")
                
            # Extract the zip file
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(self.exploitdb_path)
                
            # Find the extracted directory
            for item in os.listdir(self.exploitdb_path):
                item_path = os.path.join(self.exploitdb_path, item)
                if os.path.isdir(item_path) and "exploitdb" in item.lower():
                    # Move contents up one level
                    for subitem in os.listdir(item_path):
                        shutil.move(
                            os.path.join(item_path, subitem),
                            os.path.join(self.exploitdb_path, subitem)
                        )
                    # Remove the now-empty directory
                    try:
                        os.rmdir(item_path)
                    except:
                        pass
                        
            # Clean up zip file
            try:
                os.remove(zip_path)
            except:
                pass
        
        # Make searchsploit executable on Unix systems
        if platform.system() != "Windows":
            try:
                os.chmod(self.searchsploit_path, 0o755)
            except:
                logger.warning("Failed to make searchsploit executable")
                
        # Update the exploitdb database
        self.update_database()
            
        return self.check_installation()
    
    def update_database(self):
        """Update the Exploit-DB database"""
        if not self.check_installation():
            raise Exception("Exploit-DB is not installed")
            
        logger.info("Updating Exploit-DB database...")
        result = self.run_command([self.searchsploit_path, "-u"])
        
        if result["returncode"] != 0:
            logger.warning(f"Failed to update Exploit-DB database: {result['stderr']}")
            return False
            
        return True
        
    def search(self, term, output_format="json"):
        """Search Exploit-DB for exploits matching the given term"""
        if not self.check_installation():
            raise Exception("Exploit-DB is not installed")
            
        # Determine output format flag
        format_flag = ""
        if output_format == "json":
            format_flag = "--json"
        elif output_format == "csv":
            format_flag = "--csv"
        
        # Run searchsploit command
        cmd = [self.searchsploit_path, term]
        if format_flag:
            cmd.append(format_flag)
            
        logger.info(f"Searching Exploit-DB for: {term}")
        result = self.run_command(cmd)
        
        if result["returncode"] != 0:
            logger.warning(f"Exploit-DB search failed: {result['stderr']}")
            
        # Process the output based on format
        if output_format == "json" and result["stdout"]:
            try:
                return json.loads(result["stdout"])
            except json.JSONDecodeError:
                logger.warning("Failed to parse JSON output from searchsploit")
                
        return {
            "search_term": term,
            "stdout": result["stdout"],
            "stderr": result["stderr"],
            "returncode": result["returncode"]
        }
        
    def search_cve(self, cve_id, output_format="json"):
        """Search for exploits related to a specific CVE ID"""
        # Validate CVE ID format
        if not re.match(r"CVE-\d{4}-\d{4,}", cve_id, re.IGNORECASE):
            raise ValueError(f"Invalid CVE ID format: {cve_id}. Expected format: CVE-YYYY-NNNN")
            
        return self.search(cve_id, output_format)
        
    def search_type(self, exploit_type, output_format="json"):
        """Search for exploits of a specific type"""
        return self.search(f"type:{exploit_type}", output_format)
        
    def search_platform(self, platform, output_format="json"):
        """Search for exploits targeting a specific platform"""
        return self.search(f"platform:{platform}", output_format)
        
    def get_exploit(self, exploit_id):
        """Get a specific exploit by its Exploit-DB ID"""
        if not self.check_installation():
            raise Exception("Exploit-DB is not installed")
            
        # Run searchsploit command to get the exploit
        cmd = [self.searchsploit_path, "-m", str(exploit_id)]
        
        logger.info(f"Getting exploit {exploit_id}")
        result = self.run_command(cmd)
        
        if result["returncode"] != 0:
            logger.warning(f"Failed to get exploit {exploit_id}: {result['stderr']}")
            return {
                "exploit_id": exploit_id,
                "status": "error",
                "error": result["stderr"]
            }
            
        # Parse the output to find the path to the copied exploit
        exploit_path = None
        for line in result["stdout"].splitlines():
            if "Copied to:" in line:
                exploit_path = line.split("Copied to: ")[1].strip()
                break
                
        if not exploit_path or not os.path.exists(exploit_path):
            return {
                "exploit_id": exploit_id,
                "status": "error",
                "error": "Exploit file not found"
            }
            
        # Read the exploit content
        try:
            with open(exploit_path, 'r', errors='ignore') as f:
                exploit_content = f.read()
                
            return {
                "exploit_id": exploit_id,
                "status": "success",
                "path": exploit_path,
                "content": exploit_content
            }
        except Exception as e:
            return {
                "exploit_id": exploit_id,
                "status": "error",
                "error": str(e)
            }
            
    def search_api(self, params=None):
        """Search using the Exploit-DB web API"""
        url = f"{self.api_url}/search"
        
        if not params:
            params = {}
            
        # Add pagination if not specified
        if "page" not in params:
            params["page"] = 1
            
        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            logger.error(f"API search error: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def get_recent_exploits(self, count=10):
        """Get the most recent exploits from Exploit-DB"""
        return self.search_api({"page": 1, "sort_by": "date", "sort_order": "desc", "count": count}) 