#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Exploit Search System

This module provides functionality to search for exploits for services detected in the system
and generates comprehensive reports with detailed information on how to use them.

Features:
- Service detection and identification
- Multi-source exploit searching (Exploit-DB, Metasploit, Vulners, NVD, Rapid7)
- Detailed exploitation documentation
- Comprehensive reporting with step-by-step instructions
- Integration with existing security tools
"""

import os
import sys
import json
import logging
import argparse
import datetime
import time
import requests
import re
from pathlib import Path
from typing import Dict, List, Any, Optional, Union
import importlib
import concurrent.futures

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("exploit_search_system.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ExploitSearchSystem")

# Try to import necessary components
try:
    from security_tools_integration import security_tools_manager
    SECURITY_TOOLS_AVAILABLE = True
except ImportError:
    logger.warning("SecurityToolsManager not available. Limited functionality.")
    SECURITY_TOOLS_AVAILABLE = False

try:
    from exploit_documenter import ExploitDocumenter
    EXPLOIT_DOCUMENTER_AVAILABLE = True
except ImportError:
    logger.warning("ExploitDocumenter not available. Limited documentation capabilities.")
    EXPLOIT_DOCUMENTER_AVAILABLE = False

class ExploitSearchSystem:
    """
    System for searching exploits for detected services and generating comprehensive reports.
    
    This class provides functionality to:
    1. Detect and identify services
    2. Search multiple exploit databases for relevant exploits
    3. Generate detailed documentation on how to use the exploits
    4. Create comprehensive reports with all findings
    """
    
    def __init__(self, output_dir="exploit_search_reports"):
        """
        Initialize the exploit search system.
        
        Args:
            output_dir: Directory for storing reports and results
        """
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.output_dir = output_dir
        self.report_dir = os.path.join(output_dir, f"exploit_search_{self.timestamp}")
        
        # Ensure output directories exist
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(self.report_dir, exist_ok=True)
        
        # Initialize components
        self.exploit_documenter = None
        if EXPLOIT_DOCUMENTER_AVAILABLE:
            self.exploit_documenter = ExploitDocumenter(output_dir=self.report_dir)
        
        # Initialize available exploit databases
        self.exploit_dbs = self._initialize_exploit_dbs()
        
        logger.info(f"Exploit Search System initialized with output directory: {self.report_dir}")
    
    def _initialize_exploit_dbs(self) -> Dict:
        """Initialize available exploit databases"""
        exploit_dbs = {}
        
        if SECURITY_TOOLS_AVAILABLE:
            # Check for available exploit database tools
            exploit_db_tools = [
                "ExploitDB",
                "MetasploitExploitDB",
                "VulnersScanner",
                "NVDDatabase",
                "Rapid7Database"
            ]
            
            for tool_name in exploit_db_tools:
                try:
                    exploit_dbs[tool_name] = security_tools_manager.get_tool(tool_name)
                    logger.info(f"Initialized exploit database: {tool_name}")
                except Exception as e:
                    logger.warning(f"Could not initialize {tool_name}: {str(e)}")
        
        return exploit_dbs
    
    def detect_services(self, target=None, scan_type="comprehensive") -> Dict:
        """
        Detect services running on the target.
        
        Args:
            target: Target IP, hostname, or network range
            scan_type: Type of scan to perform (quick, standard, comprehensive)
            
        Returns:
            Dict containing detected services information
        """
        logger.info(f"Detecting services on target: {target}")
        
        detected_services = {
            "timestamp": datetime.datetime.now().isoformat(),
            "target": target,
            "services": []
        }
        
        # Use available tools to detect services
        if SECURITY_TOOLS_AVAILABLE:
            # Try to use Nmap for service detection
            try:
                nmap = security_tools_manager.get_tool("NmapScanner")
                
                # Select scan parameters based on scan type
                if scan_type == "quick":
                    scan_result = nmap.scan(target, arguments="-F -sV")
                elif scan_type == "comprehensive":
                    scan_result = nmap.comprehensive_scan(target)
                else:  # standard
                    scan_result = nmap.service_detection(target)
                
                # Extract service information from Nmap results
                if "results" in scan_result:
                    parsed_results = self._parse_nmap_results(scan_result["results"])
                    detected_services["services"].extend(parsed_results)
                    logger.info(f"Detected {len(parsed_results)} services using Nmap")
                
            except Exception as e:
                logger.error(f"Error detecting services with Nmap: {str(e)}")
            
            # Try to use additional tools for service detection
            try:
                # Check if Nuclei is available for more vulnerability-focused service detection
                nuclei = security_tools_manager.get_tool("NucleiScanner")
                nuclei_results = nuclei.scan(target)
                
                # Parse Nuclei results for service information
                if "results" in nuclei_results:
                    nuclei_services = self._parse_nuclei_results(nuclei_results["results"])
                    # Add unique services not already detected by Nmap
                    for service in nuclei_services:
                        if service not in detected_services["services"]:
                            detected_services["services"].append(service)
                    
                    logger.info(f"Added {len(nuclei_services)} services from Nuclei scan")
            
            except Exception as e:
                logger.debug(f"Error detecting services with Nuclei: {str(e)}")
        
        # If no services detected via tools, try manual detection
        if not detected_services["services"]:
            logger.warning("No services detected via security tools, attempting manual detection")
            # Basic port scan fallback
            detected_services["services"] = self._manual_service_detection(target)
        
        # Save detected services to file
        services_file = os.path.join(self.report_dir, "detected_services.json")
        with open(services_file, 'w') as f:
            json.dump(detected_services, f, indent=4)
        
        logger.info(f"Service detection completed. Found {len(detected_services['services'])} services.")
        return detected_services
    
    def _parse_nmap_results(self, nmap_results) -> List[Dict]:
        """Parse Nmap results into standardized service format"""
        services = []
        
        try:
            # Handle nmaprun format from XML output
            if "nmaprun" in nmap_results:
                nmap_data = nmap_results["nmaprun"]
                hosts = nmap_data.get("host", [])
                
                # Handle single host vs list of hosts
                if not isinstance(hosts, list):
                    hosts = [hosts]
                
                for host in hosts:
                    ip = host.get("address", {}).get("addr", "unknown")
                    
                    # Extract hostname if available
                    hostname = "unknown"
                    if "hostnames" in host and "hostname" in host["hostnames"]:
                        hostnames = host["hostnames"]["hostname"]
                        if isinstance(hostnames, list) and hostnames:
                            hostname = hostnames[0].get("name", "unknown")
                        elif isinstance(hostnames, dict):
                            hostname = hostnames.get("name", "unknown")
                    
                    # Extract ports and services
                    if "ports" in host and "port" in host["ports"]:
                        ports = host["ports"]["port"]
                        
                        # Handle single port vs list of ports
                        if not isinstance(ports, list):
                            ports = [ports]
                        
                        for port in ports:
                            port_id = port.get("portid", "0")
                            protocol = port.get("protocol", "tcp")
                            state = port.get("state", {}).get("state", "unknown")
                            
                            # Only include open ports
                            if state == "open":
                                service_info = port.get("service", {})
                                service_name = service_info.get("name", "unknown")
                                product = service_info.get("product", "")
                                version = service_info.get("version", "")
                                
                                service = {
                                    "ip": ip,
                                    "hostname": hostname,
                                    "port": port_id,
                                    "protocol": protocol,
                                    "service": service_name,
                                    "product": product,
                                    "version": version,
                                    "source": "nmap"
                                }
                                
                                services.append(service)
            
            # Handle alternative format
            elif "scan" in nmap_results:
                for ip, host_data in nmap_results["scan"].items():
                    hostname = host_data.get("hostname", "unknown")
                    
                    if "tcp" in host_data:
                        for port, port_data in host_data["tcp"].items():
                            if port_data["state"] == "open":
                                service = {
                                    "ip": ip,
                                    "hostname": hostname,
                                    "port": str(port),
                                    "protocol": "tcp",
                                    "service": port_data.get("name", "unknown"),
                                    "product": port_data.get("product", ""),
                                    "version": port_data.get("version", ""),
                                    "source": "nmap"
                                }
                                
                                services.append(service)
                    
                    if "udp" in host_data:
                        for port, port_data in host_data["udp"].items():
                            if port_data["state"] == "open":
                                service = {
                                    "ip": ip,
                                    "hostname": hostname,
                                    "port": str(port),
                                    "protocol": "udp",
                                    "service": port_data.get("name", "unknown"),
                                    "product": port_data.get("product", ""),
                                    "version": port_data.get("version", ""),
                                    "source": "nmap"
                                }
                                
                                services.append(service)
        except Exception as e:
            logger.error(f"Error parsing Nmap results: {str(e)}")
        
        return services
    
    def _parse_nuclei_results(self, nuclei_results) -> List[Dict]:
        """Parse Nuclei results into standardized service format"""
        services = []
        
        try:
            for finding in nuclei_results:
                # Extract host information
                host_info = finding.get("host", "")
                match = re.match(r"(https?://)?([^:/]+)(?::(\d+))?", host_info)
                
                if match:
                    protocol = match.group(1) or "http://"
                    hostname = match.group(2)
                    port = match.group(3) or ("443" if protocol.startswith("https") else "80")
                    
                    # Try to resolve hostname to IP
                    ip = hostname
                    # Add more sophisticated IP resolution here if needed
                    
                    # Extract service information
                    service_name = finding.get("template-id", "").split('/')[0]
                    if not service_name:
                        service_name = "http" if protocol.startswith("http://") else "https"
                    
                    service = {
                        "ip": ip,
                        "hostname": hostname,
                        "port": port,
                        "protocol": "tcp",  # Assuming TCP for web services
                        "service": service_name,
                        "product": finding.get("matcher-name", ""),
                        "version": "",  # Nuclei doesn't typically provide versions
                        "source": "nuclei",
                        "vulnerability": finding.get("info", {}).get("name", "")
                    }
                    
                    services.append(service)
        
        except Exception as e:
            logger.error(f"Error parsing Nuclei results: {str(e)}")
        
        return services
    
    def _manual_service_detection(self, target) -> List[Dict]:
        """Perform manual service detection as a fallback"""
        services = []
        
        # Try to ping and check common ports
        common_ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080]
        
        for port in common_ports:
            try:
                # Simple socket connection to check if port is open
                import socket
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(1)
                result = s.connect_ex((target, port))
                s.close()
                
                if result == 0:
                    # Port is open, try to determine service
                    service_name = self._guess_service_name(port)
                    
                    service = {
                        "ip": target,
                        "hostname": target,
                        "port": str(port),
                        "protocol": "tcp",
                        "service": service_name,
                        "product": "",
                        "version": "",
                        "source": "manual"
                    }
                    
                    services.append(service)
            
            except Exception:
                pass
        
        return services
    
    def _guess_service_name(self, port) -> str:
        """Guess service name based on common port numbers"""
        common_services = {
            21: "ftp",
            22: "ssh",
            23: "telnet",
            25: "smtp",
            53: "domain",
            80: "http",
            110: "pop3",
            111: "rpcbind",
            135: "msrpc",
            139: "netbios-ssn",
            143: "imap",
            443: "https",
            445: "microsoft-ds",
            993: "imaps",
            995: "pop3s",
            1723: "pptp",
            3306: "mysql",
            3389: "ms-wbt-server",
            5900: "vnc",
            8080: "http-proxy"
        }
        
        return common_services.get(port, "unknown")
    
    def search_exploits(self, services=None, services_file=None) -> Dict:
        """
        Search for exploits for the detected services.
        
        Args:
            services: List of service dictionaries or None to use a file
            services_file: Path to a JSON file containing service information
            
        Returns:
            Dict containing exploits found for each service
        """
        # Load services from file if not provided directly
        if not services and services_file:
            try:
                with open(services_file, 'r') as f:
                    services_data = json.load(f)
                    services = services_data.get("services", [])
            except Exception as e:
                logger.error(f"Error loading services from file: {str(e)}")
                return {"error": str(e)}
        
        if not services:
            logger.error("No services provided for exploit search")
            return {"error": "No services provided"}
        
        logger.info(f"Searching exploits for {len(services)} services")
        
        results = {
            "timestamp": datetime.datetime.now().isoformat(),
            "services": services,
            "exploits": []
        }
        
        # Search for exploits for each service
        for service in services:
            service_exploits = self._search_exploits_for_service(service)
            
            # Add service info to each exploit
            for exploit in service_exploits:
                exploit["service"] = service
                results["exploits"].append(exploit)
            
            logger.info(f"Found {len(service_exploits)} exploits for {service['service']} on {service['ip']}:{service['port']}")
        
        # Save exploit search results
        results_file = os.path.join(self.report_dir, "exploit_search_results.json")
        with open(results_file, 'w') as f:
            json.dump(results, f, indent=4)
        
        logger.info(f"Exploit search completed. Found {len(results['exploits'])} exploits for {len(services)} services.")
        return results
    
    def _search_exploits_for_service(self, service) -> List[Dict]:
        """Search exploits for a specific service using multiple sources"""
        service_exploits = []
        
        # Extract service information
        service_name = service.get("service", "").lower()
        product = service.get("product", "").lower()
        version = service.get("version", "")
        
        # Skip if service name is unknown
        if service_name == "unknown":
            return service_exploits
        
        # Search in each available exploit database
        if self.exploit_dbs:
            # ExploitDB
            if "ExploitDB" in self.exploit_dbs:
                try:
                    exploitdb = self.exploit_dbs["ExploitDB"]
                    
                    # Search by service name
                    results = exploitdb.search(service_name)
                    
                    # Also search by product name if available
                    if product:
                        product_results = exploitdb.search(product)
                        # Add unique results
                        for result in product_results:
                            if result not in results:
                                results.append(result)
                    
                    # Add version-specific search if available
                    if version and product:
                        version_results = exploitdb.search(f"{product} {version}")
                        for result in version_results:
                            if result not in results:
                                results.append(result)
                    
                    # Process and add results
                    for result in results:
                        exploit = {
                            "title": result.get("title", "Unknown exploit"),
                            "description": result.get("description", ""),
                            "date": result.get("date", ""),
                            "author": result.get("author", ""),
                            "type": result.get("type", ""),
                            "platform": result.get("platform", ""),
                            "source": "ExploitDB",
                            "exploit_id": result.get("id", ""),
                            "url": f"https://www.exploit-db.com/exploits/{result.get('id', '')}",
                            "code": result.get("code", ""),
                            "confidence": self._calculate_match_confidence(service, result)
                        }
                        
                        service_exploits.append(exploit)
                
                except Exception as e:
                    logger.error(f"Error searching ExploitDB: {str(e)}")
            
            # Metasploit
            if "MetasploitExploitDB" in self.exploit_dbs:
                try:
                    metasploit = self.exploit_dbs["MetasploitExploitDB"]
                    
                    # Search by service name
                    results = metasploit.search_modules(service_name)
                    
                    # Add product-specific search if available
                    if product:
                        product_results = metasploit.search_modules(product)
                        for result in product_results:
                            if result not in results:
                                results.append(result)
                    
                    # Process and add results
                    for result in results:
                        exploit = {
                            "title": result.get("name", "Unknown Metasploit module"),
                            "description": result.get("description", ""),
                            "date": result.get("disclosure_date", ""),
                            "author": ", ".join(result.get("authors", [])),
                            "type": "metasploit",
                            "platform": ", ".join(result.get("platforms", [])),
                            "source": "Metasploit",
                            "exploit_id": result.get("fullname", ""),
                            "url": f"https://www.rapid7.com/db/modules/{result.get('fullname', '')}",
                            "code": "",  # Metasploit modules typically don't include full code
                            "metasploit_path": result.get("fullname", ""),
                            "confidence": self._calculate_match_confidence(service, result)
                        }
                        
                        service_exploits.append(exploit)
                
                except Exception as e:
                    logger.error(f"Error searching Metasploit: {str(e)}")
            
            # Vulners
            if "VulnersScanner" in self.exploit_dbs:
                try:
                    vulners = self.exploit_dbs["VulnersScanner"]
                    
                    # Search by service and version if available
                    if product and version:
                        results = vulners.scan_software(product, version)
                    else:
                        # Fallback to service name search
                        results = vulners.search(service_name)
                    
                    # Process and add results
                    for result in results:
                        exploit = {
                            "title": result.get("title", "Unknown vulnerability"),
                            "description": result.get("description", ""),
                            "date": result.get("published", ""),
                            "author": result.get("reporter", ""),
                            "type": "vulnerability",
                            "platform": "",
                            "source": "Vulners",
                            "exploit_id": result.get("id", ""),
                            "url": result.get("href", ""),
                            "cvss": result.get("cvss", {}).get("score", ""),
                            "confidence": self._calculate_match_confidence(service, result)
                        }
                        
                        service_exploits.append(exploit)
                
                except Exception as e:
                    logger.error(f"Error searching Vulners: {str(e)}")
        
        # If no exploit databases available, try simple online search
        if not service_exploits and not self.exploit_dbs:
            logger.info("No exploit databases available, falling back to simple search")
            simple_results = self._simple_exploit_search(service)
            service_exploits.extend(simple_results)
        
        return service_exploits
    
    def _calculate_match_confidence(self, service, exploit_result) -> float:
        """Calculate confidence score for exploit match to service"""
        confidence = 0.0
        
        # Extract service information
        service_name = service.get("service", "").lower()
        product = service.get("product", "").lower()
        version = service.get("version", "")
        
        # Extract exploit information
        exploit_title = exploit_result.get("title", "").lower()
        exploit_description = exploit_result.get("description", "").lower()
        exploit_type = exploit_result.get("type", "").lower()
        
        # Check for service name match
        if service_name in exploit_title:
            confidence += 0.3
        elif service_name in exploit_description:
            confidence += 0.1
        
        # Check for product match
        if product and product in exploit_title:
            confidence += 0.4
        elif product and product in exploit_description:
            confidence += 0.2
        
        # Check for version match
        if version:
            version_pattern = re.escape(version)
            if re.search(r'\b' + version_pattern + r'\b', exploit_title):
                confidence += 0.5
            elif re.search(r'\b' + version_pattern + r'\b', exploit_description):
                confidence += 0.3
        
        # Normalize confidence value
        confidence = min(confidence, 1.0)
        return round(confidence, 2)
    
    def _simple_exploit_search(self, service) -> List[Dict]:
        """Simple exploit search without specialized exploit databases"""
        exploits = []
        
        # Extract service information
        service_name = service.get("service", "").lower()
        product = service.get("product", "").lower()
        version = service.get("version", "")
        
        search_terms = []
        
        # Build search terms
        if product and version:
            search_terms.append(f"{product} {version} exploit")
        
        if product:
            search_terms.append(f"{product} exploit")
        
        if service_name:
            search_terms.append(f"{service_name} exploit")
        
        # Try to search for exploits online
        for term in search_terms:
            try:
                # Simple search approach - replace with better API if available
                url = f"https://www.exploit-db.com/search?q={term.replace(' ', '+')}"
                
                # Placeholder for simple search results
                # This would be replaced with actual web scraping or API calls
                # We're just creating a placeholder result here
                exploit = {
                    "title": f"Search results for {term}",
                    "description": f"Please check {url} for exploits related to {term}",
                    "source": "Manual Search",
                    "url": url,
                    "confidence": 0.1
                }
                
                exploits.append(exploit)
                
                # Only need one search result suggestion
                break
            
            except Exception as e:
                logger.error(f"Error in simple exploit search: {str(e)}")
        
        return exploits
    
    def document_exploits(self, exploit_results=None, results_file=None) -> Dict:
        """
        Document detailed exploitation instructions for each exploit.
        
        Args:
            exploit_results: Dictionary containing exploit search results
            results_file: Path to JSON file containing exploit search results
            
        Returns:
            Dict containing documented exploits
        """
        # Load exploit results from file if not provided directly
        if not exploit_results and results_file:
            try:
                with open(results_file, 'r') as f:
                    exploit_results = json.load(f)
            except Exception as e:
                logger.error(f"Error loading exploit results from file: {str(e)}")
                return {"error": str(e)}
        
        if not exploit_results:
            logger.error("No exploit results provided for documentation")
            return {"error": "No exploit results provided"}
        
        logger.info(f"Documenting {len(exploit_results.get('exploits', []))} exploits")
        
        documented_results = {
            "timestamp": datetime.datetime.now().isoformat(),
            "services": exploit_results.get("services", []),
            "documented_exploits": []
        }
        
        # Use ExploitDocumenter for detailed documentation if available
        if self.exploit_documenter:
            try:
                for exploit in exploit_results.get("exploits", []):
                    # Use the new timeline-based documentation method
                    documented_exploit = self.exploit_documenter.document_exploit_with_timeline(exploit)
                    documented_results["documented_exploits"].append(documented_exploit)
            except Exception as e:
                logger.error(f"Error using ExploitDocumenter: {str(e)}")
                # Fall back to simple documentation
                for exploit in exploit_results.get("exploits", []):
                    documented_exploit = self._document_exploit(exploit)
                    documented_results["documented_exploits"].append(documented_exploit)
        else:
            # Use simple documentation without ExploitDocumenter
            for exploit in exploit_results.get("exploits", []):
                documented_exploit = self._document_exploit(exploit)
                documented_results["documented_exploits"].append(documented_exploit)
        
        # Save documented exploits to file
        documented_file = os.path.join(self.report_dir, "documented_exploits.json")
        with open(documented_file, 'w') as f:
            json.dump(documented_results, f, indent=4)
        
        logger.info(f"Exploit documentation completed. Saved to {documented_file}")
        
        # Generate comprehensive report
        report_file = self.generate_comprehensive_report(documented_results)
        documented_results["report_file"] = report_file
        
        return documented_results
    
    def _document_exploit(self, exploit) -> Dict:
        """Generate detailed documentation for an exploit"""
        documentation = {
            "summary": f"This exploit targets {exploit.get('service', {}).get('service', 'unknown')} service",
            "usage_steps": [],
            "commands": [],
            "code_examples": {},
            "prerequisites": [],
            "potential_impact": []
        }
        
        # Extract information from the service and exploit
        service = exploit.get("service", {})
        service_name = service.get("service", "").lower()
        ip = service.get("ip", "target_ip")
        port = service.get("port", "target_port")
        source = exploit.get("source", "")
        
        # Generate documentation based on the source
        if source == "ExploitDB":
            documentation["summary"] = f"This exploit was found in Exploit-DB and targets {service_name} service."
            
            # Create usage steps
            documentation["usage_steps"] = [
                f"1. Download the exploit from {exploit.get('url', '')}",
                f"2. Review the exploit code to understand its functionality and requirements",
                f"3. Ensure you have the necessary prerequisites installed",
                f"4. Modify the target information in the exploit code (replace with {ip}:{port})",
                "5. Execute the exploit according to its instructions"
            ]
            
            # Add commands
            documentation["commands"] = [
                f"# Download the exploit\ncurl -o exploit.py {exploit.get('url', '')}",
                f"# Review the exploit\ncat exploit.py",
                f"# Run the exploit (example, may need modifications)\npython exploit.py {ip} {port}"
            ]
            
            # Add code example
            if exploit.get("code"):
                documentation["code_examples"]["python"] = exploit.get("code")
        
        elif source == "Metasploit":
            documentation["summary"] = f"This exploit is available in the Metasploit Framework and targets {service_name} service."
            
            # Create usage steps
            msf_path = exploit.get("metasploit_path", "exploit/path/to/module")
            documentation["usage_steps"] = [
                "1. Start the Metasploit Framework Console",
                f"2. Use the module: {msf_path}",
                f"3. Set the RHOSTS option to {ip}",
                f"4. Set the RPORT option to {port}",
                "5. Configure other required options",
                "6. Run the exploit"
            ]
            
            # Add commands
            documentation["commands"] = [
                "# Start Metasploit Framework Console\nmsfconsole",
                f"# Use the module\nuse {msf_path}",
                f"# Set target options\nset RHOSTS {ip}\nset RPORT {port}",
                "# Show options to configure\nshow options",
                "# Run the exploit\nexploit"
            ]
            
            # Add code example
            documentation["code_examples"]["metasploit_rc"] = f"""
# Metasploit resource script
use {msf_path}
set RHOSTS {ip}
set RPORT {port}
# Add other options as needed
exploit
"""
        
        elif source == "Vulners":
            documentation["summary"] = f"This vulnerability was found in the Vulners database and affects {service_name} service."
            
            # Create usage steps
            documentation["usage_steps"] = [
                f"1. Review the vulnerability details at {exploit.get('url', '')}",
                "2. Check if public exploits are available for this vulnerability",
                "3. Test the target system for the vulnerability",
                "4. Follow recommended remediation steps"
            ]
            
            # Add basic information
            if exploit.get("cvss"):
                documentation["summary"] += f" It has a CVSS score of {exploit.get('cvss')}."
            
            # Add potential impact
            documentation["potential_impact"] = [
                "Unauthorized access",
                "Data exfiltration",
                "Service disruption",
                "System compromise"
            ]
        
        # Add prerequisites based on the service type
        if service_name in ["http", "https", "web"]:
            documentation["prerequisites"] = [
                "Web browser",
                "Burp Suite or similar proxy",
                "Python with requests library"
            ]
        elif service_name in ["ssh", "sftp"]:
            documentation["prerequisites"] = [
                "SSH client",
                "Python with paramiko library"
            ]
        elif service_name in ["ftp"]:
            documentation["prerequisites"] = [
                "FTP client",
                "Python with ftplib"
            ]
        elif service_name in ["smtp", "pop3", "imap"]:
            documentation["prerequisites"] = [
                "Email client or telnet",
                "Python with appropriate email libraries"
            ]
        else:
            documentation["prerequisites"] = [
                "Basic networking tools",
                "Python scripting capabilities",
                "Target-specific client software"
            ]
        
        return documentation
    
    def generate_comprehensive_report(self, documented_results=None, results_file=None) -> str:
        """
        Generate a comprehensive report with all findings.
        
        Args:
            documented_results: Dict containing documented exploit results
            results_file: Path to documented exploit results JSON file
            
        Returns:
            Path to the generated report
        """
        # Load results from file if not provided directly
        if not documented_results and results_file:
            try:
                with open(results_file, 'r') as f:
                    documented_results = json.load(f)
            except Exception as e:
                logger.error(f"Error loading documented results from file: {str(e)}")
                return ""
        
        if not documented_results:
            logger.error("No documented results provided for report generation")
            return ""
        
        logger.info("Generating comprehensive report")
        
        # Create report filename
        report_file = os.path.join(self.report_dir, "comprehensive_exploit_report.md")
        
        # Generate the report content
        report_content = f"""# Comprehensive Exploit Report

## Overview

This report contains detailed information about exploits found for services detected in the system.

**Report Generated:** {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Summary

- **Total Services Detected:** {len(documented_results.get("services", []))}
- **Total Exploits Found:** {len(documented_results.get("exploits", []))}

## Services Detected

"""
        
        # Add services information
        for i, service in enumerate(documented_results.get("services", []), 1):
            report_content += f"### {i}. {service.get('service', 'Unknown').upper()} ({service.get('ip', 'Unknown')}:{service.get('port', 'Unknown')})\n\n"
            report_content += f"- **IP Address:** {service.get('ip', 'Unknown')}\n"
            report_content += f"- **Port:** {service.get('port', 'Unknown')}\n"
            report_content += f"- **Protocol:** {service.get('protocol', 'Unknown')}\n"
            
            if service.get('product'):
                report_content += f"- **Product:** {service.get('product')}\n"
            
            if service.get('version'):
                report_content += f"- **Version:** {service.get('version')}\n"
            
            report_content += "\n"
        
        # Add exploits information
        report_content += "## Exploits Found\n\n"
        
        # Group exploits by service
        service_exploits = {}
        for exploit in documented_results.get("exploits", []):
            service = exploit.get("service", {})
            service_key = f"{service.get('service', 'Unknown')} ({service.get('ip', 'Unknown')}:{service.get('port', 'Unknown')})"
            
            if service_key not in service_exploits:
                service_exploits[service_key] = []
            
            service_exploits[service_key].append(exploit)
        
        # Add exploits by service
        for service_name, exploits in service_exploits.items():
            report_content += f"### Exploits for {service_name}\n\n"
            
            for i, exploit in enumerate(exploits, 1):
                confidence = exploit.get("confidence", 0) * 100
                confidence_str = f"{confidence:.0f}% confidence"
                report_content += f"#### {i}. {exploit.get('title', 'Unknown Exploit')} ({confidence_str})\n\n"
                
                report_content += f"- **Source:** {exploit.get('source', 'Unknown')}\n"
                
                if exploit.get('url'):
                    report_content += f"- **URL:** {exploit.get('url')}\n"
                
                if exploit.get('date'):
                    report_content += f"- **Date:** {exploit.get('date')}\n"
                
                if exploit.get('author'):
                    report_content += f"- **Author:** {exploit.get('author')}\n"
                
                if exploit.get('description'):
                    report_content += f"\n**Description:** {exploit.get('description')}\n\n"
                
                # Add documentation
                documentation = exploit.get("documentation", {})
                if documentation:
                    report_content += "##### Detailed Usage Information\n\n"
                    
                    if documentation.get("summary"):
                        report_content += f"{documentation.get('summary')}\n\n"
                    
                    if documentation.get("usage_steps"):
                        report_content += "**Step-by-Step Instructions:**\n\n"
                        for step in documentation.get("usage_steps"):
                            report_content += f"{step}\n"
                        report_content += "\n"
                    
                    if documentation.get("prerequisites"):
                        report_content += "**Prerequisites:**\n\n"
                        for prereq in documentation.get("prerequisites"):
                            report_content += f"- {prereq}\n"
                        report_content += "\n"
                    
                    if documentation.get("commands"):
                        report_content += "**Example Commands:**\n\n"
                        for cmd in documentation.get("commands"):
                            report_content += f"```bash\n{cmd}\n```\n\n"
                    
                    if documentation.get("code_examples"):
                        report_content += "**Code Examples:**\n\n"
                        for lang, code in documentation.get("code_examples").items():
                            report_content += f"```{lang}\n{code}\n```\n\n"
                    
                    if documentation.get("potential_impact"):
                        report_content += "**Potential Impact:**\n\n"
                        for impact in documentation.get("potential_impact"):
                            report_content += f"- {impact}\n"
                        report_content += "\n"
                
                report_content += "---\n\n"
        
        # Add disclaimer
        report_content += """## Disclaimer

This report is for authorized security testing purposes only. The exploitation techniques described in this document should only be used on systems you own or have explicit permission to test. Unauthorized use of these techniques is illegal and unethical.

## Further Information

For detailed exploitation steps and techniques, please refer to the exploitation guide document generated alongside this report.
"""
        
        # Write the report to file
        with open(report_file, 'w') as f:
            f.write(report_content)
        
        logger.info(f"Comprehensive report generated: {report_file}")
        
        # Also generate an HTML version if possible
        try:
            html_file = os.path.join(self.report_dir, "comprehensive_exploit_report.html")
            
            # Try to convert markdown to HTML
            try:
                import markdown
                with open(report_file, 'r') as f:
                    md_content = f.read()
                
                html_content = f"""
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Comprehensive Exploit Report</title>
                    <style>
                        body {{ font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; color: #333; }}
                        h1 {{ color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }}
                        h2 {{ color: #2980b9; margin-top: 30px; }}
                        h3 {{ color: #3498db; margin-top: 25px; }}
                        h4 {{ color: #2c3e50; margin-top: 20px; }}
                        h5 {{ color: #2c3e50; margin-top: 15px; }}
                        pre {{ background: #f8f8f8; border: 1px solid #ddd; border-radius: 3px; padding: 10px; overflow-x: auto; }}
                        code {{ background: #f8f8f8; padding: 2px 5px; border-radius: 3px; }}
                        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                        th {{ background-color: #f2f2f2; }}
                        tr:nth-child(even) {{ background-color: #f9f9f9; }}
                        a {{ color: #3498db; text-decoration: none; }}
                        a:hover {{ text-decoration: underline; }}
                        .warning {{ background-color: #fcf8e3; border: 1px solid #faebcc; color: #8a6d3b; padding: 15px; border-radius: 4px; margin: 20px 0; }}
                    </style>
                </head>
                <body>
                    {markdown.markdown(md_content, extensions=['tables', 'fenced_code'])}
                </body>
                </html>
                """
                
                with open(html_file, 'w') as f:
                    f.write(html_content)
                
                logger.info(f"HTML report generated: {html_file}")
            except ImportError:
                logger.warning("Python 'markdown' module not available. HTML report not generated.")
        except Exception as e:
            logger.error(f"Error generating HTML report: {str(e)}")
        
        return report_file

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="Exploit Search System")
    parser.add_argument("--target", "-t", help="Target IP address, hostname, or network range")
    parser.add_argument("--scan-type", choices=["quick", "standard", "comprehensive"], default="standard", help="Type of scan to perform")
    parser.add_argument("--output-dir", "-o", default="exploit_search_reports", help="Output directory for reports")
    parser.add_argument("--services-file", "-s", help="Path to a JSON file containing service information")
    parser.add_argument("--results-file", "-r", help="Path to a JSON file containing exploit search results")
    
    args = parser.parse_args()
    
    # Create the exploit search system
    search_system = ExploitSearchSystem(output_dir=args.output_dir)
    
    # Detect services if target is provided
    if args.target:
        detected_services = search_system.detect_services(target=args.target, scan_type=args.scan_type)
        
        # Search for exploits
        exploit_results = search_system.search_exploits(services=detected_services.get("services", []))
        
        # Document exploits
        documented_results = search_system.document_exploits(exploit_results=exploit_results)
        
        # Generate report
        report_file = search_system.generate_comprehensive_report(documented_results=documented_results)
        
        print(f"Comprehensive report generated: {report_file}")
    
    # Use services file if provided
    elif args.services_file:
        # Search for exploits
        exploit_results = search_system.search_exploits(services_file=args.services_file)
        
        # Document exploits
        documented_results = search_system.document_exploits(exploit_results=exploit_results)
        
        # Generate report
        report_file = search_system.generate_comprehensive_report(documented_results=documented_results)
        
        print(f"Comprehensive report generated: {report_file}")
    
    # Use results file if provided
    elif args.results_file:
        # Document exploits
        documented_results = search_system.document_exploits(results_file=args.results_file)
        
        # Generate report
        report_file = search_system.generate_comprehensive_report(documented_results=documented_results)
        
        print(f"Comprehensive report generated: {report_file}")
    
    else:
        parser.print_help()
    
    return 0

if __name__ == "__main__":
    sys.exit(main()) 