#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import json
import logging
import datetime
import time
import markdown
import pdfkit
import jinja2
from collections import defaultdict
from pathlib import Path

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("vulnerability_reporting.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("VulnerabilityReporter")

class VulnerabilityReporter:
    """
    Comprehensive Vulnerability Reporter for generating detailed security reports.
    
    Features:
    - Detailed vulnerability documentation
    - Step-by-step exploitation scenarios
    - Impact analysis
    - Detailed remediation instructions
    - Risk prioritization
    - Multiple output formats (JSON, HTML, PDF)
    """
    
    def __init__(self, report_dir="security_reports"):
        self.report_dir = report_dir
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Ensure report directory exists
        os.makedirs(self.report_dir, exist_ok=True)
        
        # Define risk rating system
        self.risk_levels = {
            "Critical": {
                "score_range": (9, 10),
                "color": "#FF0000",  # Red
                "description": "Immediate action required. These vulnerabilities represent an immediate and direct threat to the organization."
            },
            "High": {
                "score_range": (7, 8.9),
                "color": "#FF4500",  # OrangeRed
                "description": "Urgent action required. These vulnerabilities could lead to significant data compromise or system takeover."
            },
            "Medium": {
                "score_range": (4, 6.9),
                "color": "#FFA500",  # Orange
                "description": "Action required. These vulnerabilities pose a moderate risk to the organization's assets."
            },
            "Low": {
                "score_range": (1, 3.9),
                "color": "#FFFF00",  # Yellow
                "description": "Should be addressed in the regular development cycle. These vulnerabilities pose minimal risk."
            },
            "Informational": {
                "score_range": (0, 0.9),
                "color": "#1E90FF",  # DodgerBlue
                "description": "These findings do not represent a direct security risk but may help attackers gather information about the system."
            }
        }
        
        # Load templates
        self.template_loader = jinja2.FileSystemLoader(searchpath="./templates")
        self.template_env = jinja2.Environment(loader=self.template_loader)
        
        # Try to create templates directory if it doesn't exist
        os.makedirs("./templates", exist_ok=True)
        
        # Create report template if it doesn't exist
        self._ensure_report_templates_exist()
    
    def _ensure_report_templates_exist(self):
        """Ensure that the report templates exist, create them if they don't"""
        report_template_path = os.path.join("templates", "vulnerability_report.html")
        
        if not os.path.exists(report_template_path):
            # Create a basic template
            template_content = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ report.title }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3, h4 {
            color: #1a5276;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .executive-summary {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        .vulnerability {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .critical {
            border-left: 5px solid {{ risk_levels.Critical.color }};
        }
        .high {
            border-left: 5px solid {{ risk_levels.High.color }};
        }
        .medium {
            border-left: 5px solid {{ risk_levels.Medium.color }};
        }
        .low {
            border-left: 5px solid {{ risk_levels.Low.color }};
        }
        .informational {
            border-left: 5px solid {{ risk_levels.Informational.color }};
        }
        .severity-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            margin-right: 10px;
        }
        .severity-critical {
            background-color: {{ risk_levels.Critical.color }};
        }
        .severity-high {
            background-color: {{ risk_levels.High.color }};
        }
        .severity-medium {
            background-color: {{ risk_levels.Medium.color }};
        }
        .severity-low {
            background-color: {{ risk_levels.Low.color }};
        }
        .severity-informational {
            background-color: {{ risk_levels.Informational.color }};
        }
        .exploitation-steps {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
        }
        .remediation {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
        }
        .code-block {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            padding: 10px;
            text-align: left;
        }
        td {
            padding: 10px;
        }
        .risk-chart {
            margin: 30px 0;
        }
        .footer {
            margin-top: 50px;
            text-align: center;
            font-size: 0.9em;
            color: #666;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ report.title }}</h1>
        <p>Generated on: {{ report.date }}</p>
        <p>Target: {{ report.target }}</p>
    </div>
    
    <div class="executive-summary">
        <h2>Executive Summary</h2>
        <p>{{ report.executive_summary }}</p>
        
        <h3>Risk Overview</h3>
        <p>Overall Risk Rating: <span class="severity-badge severity-{{ report.overall_risk_level|lower }}">{{ report.overall_risk_level }}</span></p>
        
        <table>
            <tr>
                <th>Risk Level</th>
                <th>Count</th>
            </tr>
            {% for level, count in report.risk_summary.items() %}
            <tr>
                <td><span class="severity-badge severity-{{ level|lower }}">{{ level }}</span></td>
                <td>{{ count }}</td>
            </tr>
            {% endfor %}
        </table>
    </div>
    
    <h2>Vulnerability Details</h2>
    
    {% for vuln in report.vulnerabilities %}
    <div class="vulnerability {{ vuln.severity|lower }}">
        <h3>
            <span class="severity-badge severity-{{ vuln.severity|lower }}">{{ vuln.severity }}</span>
            {{ vuln.name }}
        </h3>
        
        <table>
            <tr>
                <th>Category</th>
                <td>{{ vuln.category }}</td>
            </tr>
            <tr>
                <th>Risk Score</th>
                <td>{{ vuln.risk_score }}</td>
            </tr>
            <tr>
                <th>Affected Component</th>
                <td>{{ vuln.affected_component }}</td>
            </tr>
            <tr>
                <th>CVSS Vector (if applicable)</th>
                <td>{{ vuln.cvss_vector|default('N/A') }}</td>
            </tr>
        </table>
        
        <h4>Description</h4>
        <p>{{ vuln.description }}</p>
        
        <h4>Technical Details</h4>
        <p>{{ vuln.technical_details }}</p>
        
        <h4>Exploitation Scenario</h4>
        <div class="exploitation-steps">
            <h5>Steps to Reproduce</h5>
            <ol>
                {% for step in vuln.exploitation_steps %}
                <li>{{ step }}</li>
                {% endfor %}
            </ol>
            
            {% if vuln.exploitation_code %}
            <h5>Proof of Concept</h5>
            <div class="code-block">
                <pre>{{ vuln.exploitation_code }}</pre>
            </div>
            {% endif %}
        </div>
        
        <h4>Impact</h4>
        <p>{{ vuln.impact }}</p>
        
        <h4>Remediation</h4>
        <div class="remediation">
            <p>{{ vuln.remediation.description }}</p>
            
            <h5>Recommended Steps</h5>
            <ol>
                {% for step in vuln.remediation.steps %}
                <li>{{ step }}</li>
                {% endfor %}
            </ol>
            
            {% if vuln.remediation.code_examples %}
            <h5>Code Examples</h5>
            <div class="code-block">
                <pre>{{ vuln.remediation.code_examples }}</pre>
            </div>
            {% endif %}
            
            <h5>Additional Resources</h5>
            <ul>
                {% for resource in vuln.remediation.references %}
                <li><a href="{{ resource.url }}">{{ resource.title }}</a></li>
                {% endfor %}
            </ul>
        </div>
    </div>
    {% endfor %}
    
    <h2>Remediation Plan</h2>
    <p>{{ report.remediation_plan.description }}</p>
    
    <h3>Prioritized Actions</h3>
    <ol>
        {% for action in report.remediation_plan.prioritized_actions %}
        <li>{{ action }}</li>
        {% endfor %}
    </ol>
    
    <h2>Methodology</h2>
    <p>{{ report.methodology.description }}</p>
    
    <h3>Testing Phases</h3>
    <ol>
        {% for phase in report.methodology.phases %}
        <li>{{ phase }}</li>
        {% endfor %}
    </ol>
    
    <div class="footer">
        <p>Report generated by Security Vulnerability Assessment Tool</p>
        <p>{{ report.footer }}</p>
    </div>
</body>
</html>"""
            
            # Write the template to the file
            with open(report_template_path, 'w', encoding='utf-8') as f:
                f.write(template_content)
    
    def calculate_risk_score(self, vulnerability):
        """
        Calculate a risk score based on the vulnerability details.
        
        Factors considered:
        - Impact (1-10)
        - Exploitability (1-10)
        - Data sensitivity (1-10)
        - Affected users (1-10)
        
        Returns a score from 0 to 10.
        """
        # Extract scores from vulnerability details (if available)
        impact = vulnerability.get("impact_score", 5)
        exploitability = vulnerability.get("exploitability_score", 5)
        data_sensitivity = vulnerability.get("data_sensitivity", 5)
        affected_users = vulnerability.get("affected_users", 5)
        
        # Calculate weighted average
        # - Impact and exploitability are weighted more heavily
        weighted_score = (
            impact * 0.35 +
            exploitability * 0.35 +
            data_sensitivity * 0.15 +
            affected_users * 0.15
        )
        
        # Round to 1 decimal place
        return round(weighted_score, 1)
    
    def determine_risk_level(self, risk_score):
        """Determine the risk level based on the risk score"""
        for level, details in self.risk_levels.items():
            min_score, max_score = details["score_range"]
            if min_score <= risk_score <= max_score:
                return level
        
        # Default to Informational if no match
        return "Informational"
    
    def generate_report(self, scan_results, output_format="all"):
        """
        Generate a comprehensive vulnerability report.
        
        Args:
            scan_results: The results of the vulnerability scan
            output_format: The output format for the report ('json', 'html', 'pdf', or 'all')
        
        Returns:
            A dictionary with paths to the generated report files
        """
        logger.info("Generating vulnerability report")
        
        # Create a report directory with timestamp
        report_path = os.path.join(self.report_dir, f"vulnerability_report_{self.timestamp}")
        os.makedirs(report_path, exist_ok=True)
        
        # Process vulnerabilities
        processed_vulnerabilities = []
        risk_summary = defaultdict(int)
        
        for vuln in scan_results.get("vulnerabilities", []):
            # Calculate risk score if not provided
            if "risk_score" not in vuln:
                vuln["risk_score"] = self.calculate_risk_score(vuln)
            
            # Determine risk level if not provided
            if "severity" not in vuln:
                vuln["severity"] = self.determine_risk_level(vuln["risk_score"])
            
            # Ensure all required fields are present
            processed_vuln = {
                "name": vuln.get("type", "Unknown Vulnerability"),
                "severity": vuln.get("severity", "Informational"),
                "risk_score": vuln.get("risk_score", 1.0),
                "category": vuln.get("type", "Other"),
                "affected_component": vuln.get("parameter", "Unknown"),
                "description": vuln.get("details", "No description available"),
                "technical_details": vuln.get("details", "No technical details available"),
                "exploitation_scenario": vuln.get("exploitation_scenario", "A potential attacker could exploit this vulnerability to compromise the system."),
                "exploitation_steps": vuln.get("exploitation_steps", ["1. Identify the vulnerable component", "2. Prepare the exploit", "3. Execute the exploit"]) if isinstance(vuln.get("exploitation_steps"), list) else (vuln.get("exploitation_steps", "").split("\n") if isinstance(vuln.get("exploitation_steps"), str) else ["1. Identify the vulnerable component", "2. Prepare the exploit", "3. Execute the exploit"]),
                "exploitation_code": vuln.get("payload", ""),
                "impact": vuln.get("impact", "Impact not specified"),
                "detailed_risk_info": self._generate_detailed_risk_info(vuln) if vuln.get("severity") != "Informational" else {},
                "remediation": {
                    "description": "No specific remediation details provided.",
                    "steps": ["Consult with security team for proper remediation steps."],
                    "code_examples": "",
                    "references": []
                }
            }
            
            # If exploitation_examples exist, use them to enhance the vulnerability
            if "type" in vuln and vuln["type"] in scan_results.get("exploitation_paths", {}):
                exploit_info = scan_results["exploitation_paths"].get(vuln["type"], {})
                processed_vuln["description"] = exploit_info.get("description", processed_vuln["description"])
                processed_vuln["impact"] = exploit_info.get("impact", processed_vuln["impact"])
                processed_vuln["exploitation_code"] = exploit_info.get("exploitation_code", processed_vuln["exploitation_code"])
            
            # Count vulnerabilities by risk level
            risk_summary[processed_vuln["severity"]] += 1
            
            # Process the vulnerability
            processed_vulnerabilities.append(processed_vuln)
        
        # Calculate overall risk level
        if processed_vulnerabilities:
            avg_risk_score = sum(v["risk_score"] for v in processed_vulnerabilities) / len(processed_vulnerabilities)
            overall_risk_level = self.determine_risk_level(avg_risk_score)
        else:
            avg_risk_score = 0
            overall_risk_level = "Informational"
        
        # Create report structure
        report = {
            "title": f"Vulnerability Assessment Report for {scan_results.get('target', 'Unknown Target')}",
            "date": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "target": scan_results.get("target", "Unknown Target"),
            "executive_summary": self._generate_executive_summary(scan_results, risk_summary),
            "overall_risk_level": overall_risk_level,
            "average_risk_score": avg_risk_score,
            "risk_summary": dict(risk_summary),
            "vulnerabilities": processed_vulnerabilities,
            "remediation_plan": self._generate_remediation_plan(processed_vulnerabilities),
            "methodology": {
                "description": "This assessment used a comprehensive approach to identify security vulnerabilities in the target system.",
                "phases": [
                    "Reconnaissance and Information Gathering",
                    "Automated Vulnerability Scanning",
                    "Manual Testing and Validation",
                    "Exploitation Verification",
                    "Impact Analysis",
                    "Report Generation"
                ]
            },
            "footer": "Confidential - For internal use only"
        }
        
        # Generate reports in requested formats
        generated_files = {}
        
        if output_format in ["json", "all"]:
            json_path = os.path.join(report_path, "vulnerability_report.json")
            with open(json_path, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=4)
            generated_files["json"] = json_path
            logger.info(f"JSON report generated: {json_path}")
        
        if output_format in ["html", "all"]:
            html_path = os.path.join(report_path, "vulnerability_report.html")
            try:
                template = self.template_env.get_template("vulnerability_report.html")
                html_content = template.render(report=report, risk_levels=self.risk_levels)
                with open(html_path, 'w', encoding='utf-8') as f:
                    f.write(html_content)
                generated_files["html"] = html_path
                logger.info(f"HTML report generated: {html_path}")
            except Exception as e:
                logger.error(f"Error generating HTML report: {str(e)}")
                # Fallback to simplified HTML if template fails
                self._generate_fallback_html_report(report, html_path)
                generated_files["html"] = html_path
        
        if output_format in ["pdf", "all"]:
            pdf_path = os.path.join(report_path, "vulnerability_report.pdf")
            try:
                # Convert HTML to PDF if we have HTML report
                if "html" in generated_files:
                    pdfkit.from_file(generated_files["html"], pdf_path)
                    generated_files["pdf"] = pdf_path
                    logger.info(f"PDF report generated: {pdf_path}")
                else:
                    logger.error("Cannot generate PDF: HTML report not available")
            except Exception as e:
                logger.error(f"Error generating PDF report: {str(e)}")
        
        return generated_files
    
    def _generate_executive_summary(self, scan_results, risk_summary):
        """Generate an executive summary for the report"""
        target = scan_results.get("target", "the target system")
        total_vulns = sum(risk_summary.values())
        
        critical_high = risk_summary.get("Critical", 0) + risk_summary.get("High", 0)
        
        if critical_high > 0:
            risk_description = "significant security concerns"
        elif risk_summary.get("Medium", 0) > 0:
            risk_description = "moderate security concerns"
        elif risk_summary.get("Low", 0) > 0:
            risk_description = "minor security concerns"
        else:
            risk_description = "minimal security concerns"
        
        summary = f"""
The security assessment of {target} identified {total_vulns} vulnerabilities, indicating {risk_description}. 
"""
        
        if critical_high > 0:
            summary += f"The presence of {critical_high} Critical/High risk findings requires immediate attention. "
        
        if "reconnaissance" in scan_results:
            tech_info = scan_results.get("reconnaissance", {}).get("passive", {})
            if tech_info:
                summary += "The assessment identified technical information that could be valuable for attackers. "
        
        summary += """
This report provides detailed information about each vulnerability, including step-by-step exploitation scenarios, 
potential impact, and recommended remediation actions. A prioritized remediation plan is also included 
to help address the most critical issues first.
"""
        
        return summary.strip()
    
    def _generate_remediation_plan(self, vulnerabilities):
        """Generate a prioritized remediation plan"""
        # Sort vulnerabilities by risk score (highest first)
        sorted_vulns = sorted(vulnerabilities, key=lambda v: v.get("risk_score", 0), reverse=True)
        
        # Create plan
        prioritized_actions = []
        for i, vuln in enumerate(sorted_vulns[:10]):  # Top 10 vulnerabilities
            action = f"Address {vuln.get('name')} vulnerability in {vuln.get('affected_component', 'the system')} - {vuln.get('severity')} risk"
            prioritized_actions.append(action)
        
        # Add general recommendations if few vulnerabilities were found
        if len(prioritized_actions) < 5:
            general_recommendations = [
                "Implement a regular vulnerability scanning program",
                "Conduct security awareness training for development teams",
                "Establish a security review process for all code changes",
                "Implement a responsible disclosure policy",
                "Consider implementing a web application firewall"
            ]
            prioritized_actions.extend(general_recommendations)
        
        return {
            "description": "The following actions are recommended to address the identified vulnerabilities, prioritized by risk level:",
            "prioritized_actions": prioritized_actions[:15]  # Limit to 15 recommendations
        }
    
    def _generate_detailed_risk_info(self, vulnerability):
        """Generate detailed risk information for a vulnerability"""
        risk_level = vulnerability.get("severity", "Informational")
        
        # Default detailed risk information
        detailed_info = {
            "likelihood": "Medium",
            "data_exposure": "Potential exposure of sensitive data",
            "affected_systems": "Systems handling the vulnerable component",
            "attack_vector": vulnerability.get("attack_vector", "Network/Web"),
            "potential_attackers": "External threat actors, malicious users",
            "mitigation_complexity": "Moderate - requires specific security controls"
        }
        
        # Enhance with vulnerability-specific information if available
        if "risk_details" in vulnerability and isinstance(vulnerability["risk_details"], dict):
            detailed_info.update(vulnerability["risk_details"])
            
        return detailed_info
    
    def _generate_fallback_html_report(self, report, output_path):
        """Generate a simplified HTML report when the full template fails"""
        try:
            html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{report['title']}</title>
    <style>
        body {{ font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; }}
        h1, h2, h3 {{ color: #2c3e50; }}
        .vuln {{ border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 5px; }}
        .critical {{ border-left: 5px solid #ff0000; }}
        .high {{ border-left: 5px solid #ff4500; }}
        .medium {{ border-left: 5px solid #ffa500; }}
        .low {{ border-left: 5px solid #ffff00; }}
        .info {{ border-left: 5px solid #1e90ff; }}
        .badge {{ 
            display: inline-block; 
            padding: 3px 7px; 
            color: white; 
            border-radius: 3px; 
            font-size: 12px; 
            font-weight: bold;
            margin-right: 5px;
        }}
        .critical-bg {{ background-color: #ff0000; }}
        .high-bg {{ background-color: #ff4500; }}
        .medium-bg {{ background-color: #ffa500; }}
        .low-bg {{ background-color: #ffff00; color: black; }}
        .info-bg {{ background-color: #1e90ff; }}
        code {{ background-color: #f5f5f5; padding: 2px 5px; border-radius: 3px; font-family: monospace; }}
        pre {{ background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }}
        table {{ border-collapse: collapse; width: 100%; }}
        table, th, td {{ border: 1px solid #ddd; }}
        th {{ background-color: #f2f2f2; padding: 8px; text-align: left; }}
        td {{ padding: 8px; }}
        .footer {{ margin-top: 30px; text-align: center; font-size: 0.8em; color: #777; }}
    </style>
</head>
<body>
    <h1>{report['title']}</h1>
    <p>Generated on {report['date']}</p>
    <p>Target: {report['target']}</p>
    
    <h2>Executive Summary</h2>
    <p>{report['executive_summary']}</p>
    
    <h3>Risk Overview</h3>
    <p>Overall Risk: <span class="badge {report['overall_risk_level'].lower()}-bg">{report['overall_risk_level']}</span></p>
    
    <table>
        <tr>
            <th>Risk Level</th>
            <th>Count</th>
        </tr>"""
            
            for level, count in report['risk_summary'].items():
                html += f"""
        <tr>
            <td><span class="badge {level.lower()}-bg">{level}</span></td>
            <td>{count}</td>
        </tr>"""
            
            html += """
    </table>
    
    <h2>Vulnerability Details</h2>
    """
            
            for vuln in report['vulnerabilities']:
                severity_class = vuln['severity'].lower()
                html += f"""
    <div class="vuln {severity_class}">
        <h3><span class="badge {severity_class}-bg">{vuln['severity']}</span> {vuln['name']}</h3>
        
        <p><strong>Category:</strong> {vuln['category']}</p>
        <p><strong>Risk Score:</strong> {vuln['risk_score']}</p>
        <p><strong>Affected Component:</strong> {vuln['affected_component']}</p>
        
        <h4>Description</h4>
        <p>{vuln['description']}</p>
        
        <h4>Technical Details</h4>
        <p>{vuln['technical_details']}</p>"""
                
                if vuln.get('exploitation_steps'):
                    html += f"""
        <h4>Exploitation Steps</h4>
        <ol>"""
                    if isinstance(vuln['exploitation_steps'], list):
                        for step in vuln['exploitation_steps']:
                            html += f"<li>{step}</li>"
                    else:
                        html += f"<li>{vuln['exploitation_steps']}</li>"
                    html += "</ol>"
                
                if vuln.get('exploitation_code'):
                    html += f"""
        <h4>Proof of Concept</h4>
        <pre><code>{vuln['exploitation_code']}</code></pre>"""
                
                if vuln.get('impact'):
                    html += f"""
        <h4>Impact</h4>
        <p>{vuln['impact']}</p>"""
                
                # Add check for remediation attribute
                if isinstance(vuln.get('remediation'), dict):
                    remediation = vuln['remediation']
                    html += f"""
        <h4>Remediation</h4>
        <p>{remediation.get('description', 'No remediation details provided.')}</p>"""
                    
                    if remediation.get('steps'):
                        html += """
        <h5>Remediation Steps</h5>
        <ol>"""
                        for step in remediation['steps']:
                            html += f"<li>{step}</li>"
                        html += "</ol>"
                    
                    if remediation.get('code_examples'):
                        html += f"""
        <h5>Code Examples</h5>
        <pre><code>{remediation['code_examples']}</code></pre>"""
                else:
                    html += """
        <h4>Remediation</h4>
        <p>No specific remediation details provided.</p>"""
                
                html += """
    </div>"""
            
            html += f"""
    <h2>Remediation Plan</h2>
    <p>{report['remediation_plan']['description']}</p>
    
    <h3>Prioritized Actions</h3>
    <ol>"""
            
            for action in report['remediation_plan']['prioritized_actions']:
                html += f"<li>{action}</li>"
            
            html += f"""
    </ol>
    
    <div class="footer">
        <p>Report generated by Security Vulnerability Assessment Tool</p>
        <p>{report['footer']}</p>
    </div>
</body>
</html>"""
            
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(html)
            
            return True
        except Exception as e:
            logger.error(f"Error generating fallback HTML report: {str(e)}")
            return False

    def generate_vulnerable_component_report(self, vulnerability_data):
        """
        Generate a detailed report specifically focusing on vulnerable components
        with a detailed schedule for each component.
        
        Args:
            vulnerability_data: Dictionary containing vulnerability information
            
        Returns:
            str: Markdown-formatted report for vulnerable components
        """
        report = []
        report.append("# Детальный отчет об уязвимых компонентах")
        report.append("\n## Обзор уязвимых компонентов\n")
        
        if not vulnerability_data or "vulnerabilities" not in vulnerability_data:
            report.append("Уязвимые компоненты не обнаружены.")
            return "\n".join(report)
        
        vulnerabilities = vulnerability_data.get("vulnerabilities", [])
        
        # Group vulnerabilities by component
        components = {}
        for vuln in vulnerabilities:
            component = vuln.get("component", "Неизвестный компонент")
            if component not in components:
                components[component] = []
            components[component].append(vuln)
        
        # Generate report for each component
        for component_name, component_vulns in components.items():
            report.append(f"\n## Компонент: {component_name}\n")
            
            # Component summary
            total_vulns = len(component_vulns)
            severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
            
            for vuln in component_vulns:
                severity = vuln.get("severity", "info").lower()
                if severity in severity_counts:
                    severity_counts[severity] += 1
            
            report.append("### Сводка по компоненту\n")
            report.append(f"- **Всего уязвимостей**: {total_vulns}")
            report.append(f"- **Критических**: {severity_counts['critical']}")
            report.append(f"- **Высоких**: {severity_counts['high']}")
            report.append(f"- **Средних**: {severity_counts['medium']}")
            report.append(f"- **Низких**: {severity_counts['low']}")
            report.append(f"- **Информационных**: {severity_counts['info']}\n")
            
            # Detailed schedule for each vulnerability in the component
            report.append("### Детальное расписание выявленных уязвимостей\n")
            
            for i, vuln in enumerate(component_vulns):
                vuln_id = vuln.get("id", f"VULN-{i+1}")
                name = vuln.get("name", "Unnamed Vulnerability")
                severity = vuln.get("severity", "Unknown").upper()
                cve = vuln.get("cve_id", "N/A")
                cvss = vuln.get("cvss_score", "N/A")
                
                report.append(f"#### {i+1}. {name} [{severity}]\n")
                report.append(f"- **Идентификатор**: {vuln_id}")
                report.append(f"- **CVE**: {cve}")
                report.append(f"- **CVSS Score**: {cvss}")
                
                # Discovery timeline
                discovery_date = vuln.get("discovery_date", "Неизвестно")
                report.append(f"- **Дата обнаружения**: {discovery_date}")
                
                # Verification timeline
                verification_date = vuln.get("verification_date", "N/A")
                if verification_date != "N/A":
                    report.append(f"- **Дата подтверждения**: {verification_date}")
                
                # Exploitation potential
                report.append("\n##### Потенциал эксплуатации\n")
                
                exploit_complexity = vuln.get("exploit_complexity", "Неизвестно")
                report.append(f"- **Сложность эксплуатации**: {exploit_complexity}")
                
                exploit_availability = vuln.get("exploit_availability", "Неизвестно")
                report.append(f"- **Доступность эксплойта**: {exploit_availability}")
                
                # Vulnerability details
                report.append("\n##### Технические детали\n")
                
                description = vuln.get("description", "Нет описания")
                report.append(f"- **Описание**: {description}")
                
                affected_versions = vuln.get("affected_versions", "Все версии")
                report.append(f"- **Затронутые версии**: {affected_versions}")
                
                vulnerability_type = vuln.get("vulnerability_type", "Неизвестно")
                report.append(f"- **Тип уязвимости**: {vulnerability_type}")
                
                # Remediation timeline
                report.append("\n##### График устранения\n")
                
                remediation_available = vuln.get("remediation_available", False)
                if remediation_available:
                    remediation_type = vuln.get("remediation_type", "Патч")
                    patch_available_date = vuln.get("patch_available_date", "Неизвестно")
                    recommended_deadline = vuln.get("recommended_fix_deadline", "Как можно скорее")
                    
                    report.append(f"- **Тип исправления**: {remediation_type}")
                    report.append(f"- **Дата доступности исправления**: {patch_available_date}")
                    report.append(f"- **Рекомендуемый срок исправления**: {recommended_deadline}")
                else:
                    report.append("- **Исправление не доступно**")
                
                # Add workaround if available
                workaround = vuln.get("workaround", None)
                if workaround:
                    report.append(f"- **Временное решение**: {workaround}")
                
                report.append("\n")
        
        return "\n".join(report)

    def generate_exploit_report(self, exploit_data):
        """
        Generate a detailed report about exploits for each vulnerability.
        
        Args:
            exploit_data: Dictionary containing exploit information
            
        Returns:
            str: Markdown-formatted report for exploits
        """
        report = []
        report.append("# Детальный отчет об эксплойтах")
        report.append("\n## Обзор доступных эксплойтов\n")
        
        if not exploit_data or "exploits" not in exploit_data:
            report.append("Эксплойты не обнаружены.")
            return "\n".join(report)
        
        exploits = exploit_data.get("exploits", [])
        
        # Summary statistics
        total_exploits = len(exploits)
        
        # Categorize exploits by type
        exploit_types = {}
        for exploit in exploits:
            exploit_type = exploit.get("type", "Неизвестный тип")
            if exploit_type not in exploit_types:
                exploit_types[exploit_type] = 0
            exploit_types[exploit_type] += 1
        
        report.append(f"**Всего эксплойтов**: {total_exploits}\n")
        report.append("**Типы эксплойтов**:")
        for etype, count in exploit_types.items():
            report.append(f"- {etype}: {count}")
        
        report.append("\n## Детальная информация об эксплойтах\n")
        
        # Group exploits by vulnerability/service
        grouped_exploits = {}
        for exploit in exploits:
            service_info = exploit.get("service", {})
            service_name = service_info.get("service", "Неизвестный сервис")
            
            key = f"{service_name} ({service_info.get('ip', 'N/A')}:{service_info.get('port', 'N/A')})"
            if key not in grouped_exploits:
                grouped_exploits[key] = []
            grouped_exploits[key].append(exploit)
        
        # Generate detailed information for each exploit
        for service_key, service_exploits in grouped_exploits.items():
            report.append(f"### Сервис: {service_key}\n")
            
            for i, exploit in enumerate(service_exploits):
                title = exploit.get("title", "Неизвестный эксплойт")
                source = exploit.get("source", "Неизвестный источник")
                exploit_id = exploit.get("exploit_id", "N/A")
                
                report.append(f"#### {i+1}. {title}\n")
                report.append(f"- **Источник**: {source}")
                report.append(f"- **ID эксплойта**: {exploit_id}")
                
                # Exploit metadata
                author = exploit.get("author", "Неизвестно")
                date = exploit.get("date", "Неизвестно")
                report.append(f"- **Автор**: {author}")
                report.append(f"- **Дата**: {date}")
                
                # Technical details
                description = exploit.get("description", "Нет описания")
                report.append(f"- **Описание**: {description}")
                
                platform = exploit.get("platform", "Любая")
                report.append(f"- **Платформа**: {platform}")
                
                # Usage information
                report.append("\n##### Инструкции по использованию\n")
                
                if "usage" in exploit and exploit["usage"]:
                    usage = exploit["usage"]
                    
                    # Prerequisites
                    prerequisites = usage.get("prerequisites", [])
                    if prerequisites:
                        report.append("**Предварительные требования**:")
                        for prereq in prerequisites:
                            report.append(f"- {prereq}")
                        report.append("")
                    
                    # Step by step instructions
                    steps = usage.get("steps", [])
                    if steps:
                        report.append("**Шаги по эксплуатации**:")
                        for j, step in enumerate(steps):
                            report.append(f"{j+1}. {step}")
                        report.append("")
                    
                    # Example commands
                    commands = usage.get("commands", [])
                    if commands:
                        report.append("**Примеры команд**:")
                        for command in commands:
                            report.append(f"```\n{command}\n```")
                        report.append("")
                    
                    # Code example if available
                    code = usage.get("code_example", "")
                    if code:
                        language = usage.get("code_language", "")
                        report.append("**Пример кода**:")
                        report.append(f"```{language}\n{code}\n```")
                        report.append("")
                else:
                    report.append("Детальные инструкции по использованию не доступны.\n")
                
                # Expected outcome
                expected_outcome = exploit.get("expected_outcome", "Неизвестный результат")
                report.append(f"**Ожидаемый результат**: {expected_outcome}")
                
                # Risk assessment
                risk_level = exploit.get("risk_level", "Неизвестно")
                potential_impact = exploit.get("potential_impact", "Неизвестно")
                
                report.append("\n##### Оценка риска\n")
                report.append(f"- **Уровень риска**: {risk_level}")
                report.append(f"- **Потенциальное воздействие**: {potential_impact}")
                
                # Mitigation
                report.append("\n##### Меры защиты\n")
                mitigations = exploit.get("mitigations", ["Информация о защитных мерах не доступна"])
                for mitigation in mitigations:
                    report.append(f"- {mitigation}")
                
                report.append("\n")
        
        return "\n".join(report)

def generate_vulnerability_report(scan_results, output_dir=None, output_format="all"):
    """
    Convenience function to generate a vulnerability report.
    
    Args:
        scan_results: The results of the vulnerability scan
        output_dir: Directory to store the report
        output_format: Output format ('json', 'html', 'pdf', or 'all')
    
    Returns:
        Paths to the generated report files
    """
    if output_dir is None:
        output_dir = "security_reports"
    
    reporter = VulnerabilityReporter(report_dir=output_dir)
    return reporter.generate_report(scan_results, output_format)

if __name__ == "__main__":
    # Example usage
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate detailed vulnerability reports")
    parser.add_argument("input_file", help="JSON file containing vulnerability scan results")
    parser.add_argument("--output-dir", "-o", default="security_reports", help="Directory to store the reports")
    parser.add_argument("--format", "-f", choices=["json", "html", "pdf", "all"], default="all", help="Report format")
    
    args = parser.parse_args()
    
    # Load scan results
    try:
        with open(args.input_file, 'r') as f:
            scan_results = json.load(f)
        
        # Generate report
        report_files = generate_vulnerability_report(scan_results, args.output_dir, args.format)
        
        print(f"Reports generated in {args.output_dir}:")
        for format_type, file_path in report_files.items():
            print(f"- {format_type.upper()}: {file_path}")
            
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1) 